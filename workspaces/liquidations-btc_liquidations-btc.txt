{
  "version": 7,
  "createdAt": 1715132919941,
  "updatedAt": 1727900077251,
  "name": "liquidations_btc",
  "id": "liquidations-btc",
  "states": {
    "panes": {
      "_id": "panes",
      "locked": false,
      "panes": {
        "chart": {
          "id": "chart",
          "name": "",
          "type": "chart",
          "settings": {
            "indicatorsErrors": {
              "_7o282jzm9vulptiq": "Cannot read properties of undefined (reading '0')"
            },
            "indicators": {
              "liquidations": {
                "enabled": true,
                "name": "Liquidations",
                "description": "Liquidations by side",
                "script": "plothistogram(lbuy, color=options.upColor)\nplothistogram(-lsell, color=options.downColor)",
                "options": {
                  "priceFormat": {
                    "type": "volume"
                  },
                  "priceScaleId": "volume_liquidations",
                  "upColor": "rgb(255,76,243)",
                  "downColor": "rgb(255,183,77)",
                  "scaleMargins": {
                    "top": 0,
                    "bottom": 0.96
                  },
                  "visible": true,
                  "lastValueVisible": true,
                  "priceLineVisible": false,
                  "baseLineVisible": false
                },
                "id": "liquidations",
                "createdAt": 1700269685372,
                "updatedAt": null,
                "series": [
                  "liquidations",
                  "wb47gl80"
                ],
                "unsavedChanges": true,
                "optionsDefinitions": {}
              },
              "price": {
                "enabled": true,
                "name": "Price",
                "script": "src = { sources: { \"BINANCE_FUTURES:btcusdt\":BINANCE_FUTURES:btcusdt }, localTimestamp: time }\r\n\r\nvar ohlc = options.useHeikinAshi ? avg_heikinashi(src) : options.useGaps ? avg_ohlc_with_gaps(src) : avg_ohlc(src)\r\n\r\nplotcandlestick(ohlc, id=price)",
                "options": {
                  "priceScaleId": "right",
                  "priceFormat": {
                    "auto": true,
                    "precision": 1,
                    "minMove": 0.1
                  },
                  "priceLineVisible": true,
                  "lastValueVisible": true,
                  "borderVisible": true,
                  "upColor": "rgb(59,202,109)",
                  "downColor": "rgb(214,40,40)",
                  "borderUpColor": "rgb(59,202,109)",
                  "borderDownColor": "rgb(239,67,82)",
                  "wickUpColor": "rgb(209,212,220)",
                  "wickDownColor": "rgb(239,67,82)",
                  "useGaps": false,
                  "useHeikinAshi": false,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": true
                },
                "id": "price",
                "createdAt": 1700269685372,
                "updatedAt": 1700590671954,
                "series": [
                  "price"
                ],
                "unsavedChanges": true,
                "preview": {},
                "optionsDefinitions": {}
              },
              "orderbook-0-1-spot": {
                "script": "if(!upper){\r\n  upper = options.upper || 39\r\n  lower = options.lower || -39\r\n}\r\nvar levels = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\nvar ratioValue = levels && levels[0]\r\n\r\nplothistogram({\r\n    time: time,\r\n    value: ratioValue,\r\n    color: ratioValue < lower ? options.warnColor : ratioValue > upper ? options.warnColor : options.ratioColor\r\n}, title=\"spot\")\r\n\r\n\r\nif( upperLine === 0 ){  \r\n   upperLine = series[0].createPriceLine({ \r\n      price: upper, \r\n      index: bar.length,\r\n      color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }\r\n\r\n  if( lowerLine === 0 ){  \r\n   lowerLine = series[0].createPriceLine({ \r\n      price: lower, \r\n      index: bar.length,\r\n      color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }",
                "name": "Orderbook 0-1% spot",
                "priceScaleId": "orderbook-0-1",
                "id": "orderbook-0-1-spot",
                "options": {
                  "priceScaleId": "orderbook-0-1-spot",
                  "scaleMargins": {
                    "top": 0.71,
                    "bottom": 0.25
                  },
                  "useGaps": true,
                  "useHeikinAshi": null,
                  "priceFormat": {
                    "type": "percent",
                    "precision": 1,
                    "minMove": 0.1,
                    "auto": true
                  },
                  "visible": true,
                  "lastValueVisible": true,
                  "baseLineVisible": true,
                  "pivotLength": 14,
                  "upper": null,
                  "lowerColor": "rgb(120,123,134)",
                  "upperColor": "rgb(120,123,134)",
                  "lower": null,
                  "ratioColor": "rgb(149,152,161)",
                  "warnColor": "rgb(255,235,59)"
                },
                "series": [
                  "orderbook-0-1-spot"
                ],
                "displayName": "Orderbook 0-1% spot",
                "unsavedChanges": true,
                "preview": {},
                "createdAt": 1700590114591,
                "updatedAt": 1700636345055,
                "optionsDefinitions": {}
              },
              "orderbook-0-1-perp": {
                "script": "if(!upper){\r\n  upper = options.upper || 37\r\n  lower = options.lower || -19\r\n}\r\nvar levels = ORDERBOOK:AGGRPERP-BTCUSD.zratios \r\nvar ratioValue = levels && levels[0]\r\n\r\nplothistogram({\r\n    time: time,\r\n    value: ratioValue,\r\n    color: ratioValue <= lower ? options.warnColor : ratioValue >= upper ? options.warnColor : options.ratioColor\r\n}, title=\"perp\")\r\n\r\nif( upperLine === 0 ){  \r\n   upperLine = series[0].createPriceLine({ \r\n      price: upper, \r\n      index: bar.length,\r\n      color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }\r\n\r\n  if( lowerLine === 0 ){  \r\n   lowerLine = series[0].createPriceLine({ \r\n      price: lower, \r\n      index: bar.length,\r\n      color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }",
                "name": "Orderbook 0-1% perp",
                "priceScaleId": "orderbook-0-1",
                "id": "orderbook-0-1-perp",
                "options": {
                  "priceScaleId": "orderbook-0-1-perp",
                  "scaleMargins": {
                    "top": 0.86,
                    "bottom": 0.1
                  },
                  "useGaps": true,
                  "useHeikinAshi": null,
                  "priceFormat": {
                    "type": "percent",
                    "precision": 1,
                    "minMove": 0.1,
                    "auto": true
                  },
                  "visible": true,
                  "lastValueVisible": true,
                  "baseLineVisible": true,
                  "upper": null,
                  "lower": null,
                  "warnColor": "rgb(24,72,204)",
                  "upperColor": "rgb(12,50,153)",
                  "lowerColor": "rgb(12,50,153)",
                  "ratioColor": "rgb(178,181,190)"
                },
                "series": [
                  "orderbook-0-1-perp"
                ],
                "displayName": "Orderbook 0-1% perp",
                "unsavedChanges": true,
                "preview": {},
                "createdAt": 1700598885689,
                "updatedAt": 1700600633815,
                "optionsDefinitions": {}
              },
              "orderbook-spot": {
                "script": "var levels = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\nvar ratio1 = levels && levels[1]\r\nvar ratio2 = levels && levels[2]\r\nvar ratio3 = levels && levels[3]\r\n\r\nif( ratio1Upper === 0 ){\r\n    ratio1Upper = options.upper || 62\r\n    ratio1Lower = options.lower || -62\r\n\r\n    ratio2Upper = options.upper2 || 45\r\n    ratio2Lower = options.lower2 || -45\r\n\r\n    ratio3Upper = options.upper3 || 39\r\n    ratio3Lower = options.lower3 || -39\r\n}\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio3, \r\n    color: ratio3 < ratio3Lower ? options.warnColor : (ratio3 > ratio3Upper ? options.warnColor : options.ratio3Color)\r\n}, title=S3)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio1, \r\n    color: ratio1 < ratio1Lower ? options.warnColor : (ratio1 > ratio1Upper ? options.warnColor : options.ratio1Color)\r\n}, title=S1)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio2, \r\n    color: ratio2 < ratio2Lower ? options.warnColor : (ratio2 > ratio2Upper ? options.warnColor: options.ratio2Color)\r\n}, title=S2)\r\n\r\n/*\r\nline(ratio1Upper, color=options.upperColor)\r\nline(ratio1Lower,color=options.lowerColor)\r\n\r\nline(ratio2Upper, color=options.upper2Color)\r\nline(ratio2Lower,color=options.lower2Color)\r\n*/\r\n\r\nif( upperLine === 0 ){  \r\n    upperLine = series[0].createPriceLine({ \r\n        price: ratio1Upper, \r\n        index: bar.length,\r\n        color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine === 0 ){  \r\n    lowerLine = series[0].createPriceLine({ \r\n        price: ratio1Lower, \r\n        index: bar.length,\r\n        color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( upperLine2 === 0 ){  \r\n    upperLine2 = series[0].createPriceLine({ \r\n        price: ratio2Upper, \r\n        index: bar.length,\r\n        color: options.upper2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine2 === 0 ){  \r\n    lowerLine2 = series[0].createPriceLine({ \r\n        price: ratio2Lower, \r\n        index: bar.length,\r\n        color: options.lower2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nline(0)",
                "name": "Orderbook spot",
                "priceScaleId": "orderbook-spot",
                "id": "orderbook-spot",
                "options": {
                  "priceScaleId": "orderbook-spot",
                  "scaleMargins": {
                    "top": 0.77,
                    "bottom": 0.15
                  },
                  "lastValueVisible": true,
                  "priceFormat": {
                    "type": "percent",
                    "precision": 1,
                    "minMove": 0.1,
                    "auto": true
                  },
                  "leverages": null,
                  "ratio1": null,
                  "ratio2": null,
                  "ratio2Color": "rgb(66,189,168)",
                  "ratio1Color": "rgb(186,104,200)",
                  "visible": true,
                  "upper": null,
                  "upper2": null,
                  "lowerColor": "rgba(74,20,140,0.62)",
                  "upperColor": "rgba(171,71,188,0.59)",
                  "lower2Color": "rgba(66,189,168,0.63)",
                  "upper2Color": "rgba(34,171,148,0.62)",
                  "lower": null,
                  "lower2": null,
                  "warnColor": "rgb(245,124,0)",
                  "priceLineVisible": false,
                  "baseLineVisible": true,
                  "ratio3Color": "rgba(255,255,255,0.69)",
                  "upper3": null,
                  "lower3": null,
                  "lineStyle": 0
                },
                "series": [
                  "orderbook-spot",
                  "f161gcco",
                  "l9ezwjl6",
                  "982dqeve",
                  "9a9cln8k",
                  "xo1zi3ue",
                  "0yigqglv",
                  "jurtg0zc"
                ],
                "displayName": "Orderbook spot",
                "unsavedChanges": true,
                "preview": {},
                "createdAt": 1700599138239,
                "updatedAt": 1710448059769,
                "optionsDefinitions": {},
                "libraryId": "orderbook-spot"
              },
              "orderbook-perp": {
                "script": "var levels = ORDERBOOK:AGGRPERP-BTCUSD.zratios \r\nvar ratio1 = levels && levels[1]\r\nvar ratio2 = levels && levels[2]\r\nvar ratio3 = levels && levels[3]\r\n\r\nif( ratio1Upper === 0 ){\r\n    ratio1Upper = options.upper || 26\r\n    ratio1Lower = options.lower || -26\r\n\r\n    ratio2Upper = options.upper2 || 35\r\n    ratio2Lower = options.lower2 || -35\r\n\r\n    ratio3Upper = options.upper3 || 39\r\n    ratio3Lower = options.lower3 || -39\r\n}\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio3, \r\n    color: ratio3 < ratio3Lower ? options.warnColor : (ratio3 > ratio3Upper ? options.warnColor : options.ratio3Color)\r\n}, title=P3)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio1, \r\n    color: ratio1 < ratio1Lower ? options.warnColor : (ratio1 > ratio1Upper ? options.warnColor : options.ratio1Color)\r\n}, title=P1)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio2, \r\n    color: ratio2 < ratio2Lower ? options.warnColor : (ratio2 > ratio2Upper ? options.warnColor: options.ratio2Color)\r\n}, title=P2)\r\n\r\n/*\r\nline(ratio1Upper, color=options.upperColor)\r\nline(ratio1Lower,color=options.lowerColor)\r\n\r\nline(ratio2Upper, color=options.upper2Color)\r\nline(ratio2Lower,color=options.lower2Color)\r\n*/\r\n\r\nif( upperLine === 0 ){  \r\n    upperLine = series[0].createPriceLine({ \r\n        price: ratio1Upper, \r\n        index: bar.length,\r\n        color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine === 0 ){  \r\n    lowerLine = series[0].createPriceLine({ \r\n        price: ratio1Lower, \r\n        index: bar.length,\r\n        color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( upperLine2 === 0 ){  \r\n    upperLine2 = series[0].createPriceLine({ \r\n        price: ratio2Upper, \r\n        index: bar.length,\r\n        color: options.upper2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine2 === 0 ){  \r\n    lowerLine2 = series[0].createPriceLine({ \r\n        price: ratio2Lower, \r\n        index: bar.length,\r\n        color: options.lower2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\nline(0)",
                "name": "Orderbook Perp",
                "priceScaleId": "orderbook-perp",
                "id": "orderbook-perp",
                "options": {
                  "priceScaleId": "orderbook-perp",
                  "lower": null,
                  "lower2": -32,
                  "upper": null,
                  "upper2": 32,
                  "ratio1Color": "rgb(171,71,188)",
                  "lowerColor": "rgba(186,104,200,0.6)",
                  "warnColor": "rgb(255,152,0)",
                  "upperColor": "rgba(186,104,200,0.62)",
                  "ratio2Color": "rgb(76,175,80)",
                  "upper2Color": "rgba(76,175,80,0.67)",
                  "lower2Color": "rgba(76,175,80,0.66)",
                  "visible": true,
                  "lastValueVisible": true,
                  "scaleMargins": {
                    "top": 0.91,
                    "bottom": 0
                  },
                  "ratio3Color": "rgba(255,255,255,0.38)",
                  "upper3": null,
                  "lower3": null
                },
                "series": [
                  "orderbook-perp",
                  "j9tjw2df",
                  "uwye26m0",
                  "58pbpc2k",
                  "1zlz7cqr",
                  "c3ypeuo1",
                  "tfrjr9i0",
                  "3gof5t18"
                ],
                "displayName": "Orderbook Perp",
                "unsavedChanges": false,
                "optionsDefinitions": {},
                "libraryId": "orderbook-perp",
                "createdAt": 1700696855798,
                "updatedAt": 1710448067929
              },
              "perpvscoinbase": {
                "script": "binance = (BINANCE_FUTURES:btcusdt.high+BINANCE_FUTURES:btcusdt.low+BINANCE_FUTURES:btcusdt.close)/3 \nbybit = (BYBIT:BTCUSDT.high+BYBIT:BTCUSDT.low+BYBIT:BTCUSDT.close)/3 \nokx = (OKEX:BTC-USD-SWAP.high+OKEX:BTC-USD-SWAP.low+OKEX:BTC-USD-SWAP.close)/3 \ncoinbaseSpot = (COINBASE:BTC-USD.high+COINBASE:BTC-USD.low+ COINBASE:BTC-USD.close)/3\n\n\npremium = coinbaseSpot - (binance+bybit+okx)/3\nbaseline = 0\n\n\nplotcloudarea(premium, baseline)\n//line(\n//  ema(premium, 10)\n//)",
                "id": "perpvscoinbase",
                "name": "Coinbase prem.",
                "options": {
                  "priceScaleId": "perpvscoinbase",
                  "visible": true,
                  "priceLineVisible": true,
                  "lastValueVisible": true,
                  "lowerLineColor": "rgba(119,255,0,0)",
                  "positiveColor": "rgb(242,54,69)",
                  "negativeColor": "rgb(49,121,245)",
                  "higherLineColor": "rgba(255,255,255,0)",
                  "priceFormat": {
                    "type": "price",
                    "minMove": "0.01",
                    "precision": 1
                  },
                  "lineStyle": 1,
                  "color": "rgb(209,212,220)",
                  "scaleMargins": {
                    "top": 0.23,
                    "bottom": 0.74
                  },
                  "baseLineVisible": false
                },
                "description": null,
                "createdAt": 1681264031489,
                "updatedAt": 1705607189308,
                "unsavedChanges": false,
                "series": [
                  "perpvscoinbase"
                ],
                "displayName": "Coinbase prem.",
                "preview": {},
                "optionsDefinitions": {},
                "libraryId": "perpvscoinbase"
              },
              "large-liquidations": {
                "script": "// markers needs a serie to get attached to\r\nline($price.close, color=transparent)\r\n\r\n\r\nif (markers === 0) {\r\n  // first script execution (0 is default values for all persistent variables)\r\n\r\n  // create a var to store already drawn markers\r\n  markers = []\r\n\r\n  // contain the last marker that can change as the bar update\r\n  repaintableMarker = null\r\n\r\n  largeLiquidation = options.largeLiquidation || 3000000\r\n}\r\n\r\nif (repaintableMarker && repaintableMarker.time < time) {\r\n  // bar is +1 since active marker was added, lock it in the array\r\n  markers.push(repaintableMarker)\r\n\r\n  // free up active marker\r\n  repaintableMarker = null\r\n}\r\n\r\nvar newMarker = null\r\n\r\n// big money strategy\r\n// TODO if it has already been on once, don't show\r\nvar signal = sum(lbuy,5) + sum(lsell,5) > largeLiquidation \r\n\r\nif (signal && !iAmOn) {\r\n  console.log('HI');\r\n  \r\n  // newMarker is a temporary variable (not included in the indicator state)\r\n  // to avoid it being treated as persistent variable we wrap it inside parenthesis\r\n  (newMarker) = {\r\n    time: time,\r\n    position: 'inBar',\r\n    color: (options.markerColor || 'blue'),\r\n    shape: 'square'\r\n  }\r\n\r\n    iAmOn = true\r\n}else if (!signal){\r\n  iAmOn = false\r\n} \r\n\r\nif (newMarker || (repaintableMarker && !newMarker)) {\r\n  // override persistent variable repaintable marker\r\n  repaintableMarker = newMarker\r\n  \r\n  if (series[0].setMarkers) {\r\n    series[0].setMarkers(markers.concat(repaintableMarker))\r\n  }\r\n}",
                "name": "Large Liquidations",
                "priceScaleId": "right",
                "id": "large-liquidations",
                "options": {
                  "priceScaleId": "right",
                  "largeLiquidation": 4000000,
                  "visible": true,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "markerColor": "rgb(77,208,225)",
                  "lastValueVisible": false,
                  "priceLineVisible": false,
                  "baseLineVisible": false
                },
                "series": [
                  "large-liquidations"
                ],
                "displayName": "Large Liquidations",
                "unsavedChanges": true,
                "optionsDefinitions": {},
                "libraryId": "large-liquidations",
                "createdAt": 1700796224070,
                "updatedAt": 1710528432192
              },
              "spotvsperp": {
                "script": "var binance = (BINANCE:btcusdt.high+BINANCE:btcusdt.low)/2\r\nvar bitfinex = (BITFINEX:BTCUSD.high+BITFINEX:BTCUSD.low)/2\r\n\r\nvar binancePerp = (BINANCE_FUTURES:btcusdt.high+BINANCE_FUTURES:btcusdt.low)/2\r\nvar bybit = (BYBIT:BTCUSDT.high+BYBIT:BTCUSDT.low)/2\r\n\r\n\r\npremium =  (binancePerp + bybit) / 2 - (binance+bitfinex) / 2\r\nbaseline = 0\r\n\r\nplotcloudarea(\r\n  premium,\r\n  baseline, \r\n  positiveColor=options.topLineColor,\r\n  negativeColor=options.bottomLineColor\r\n)\r\n\r\n//line(bitfinex)",
                "name": "SpotVSPerp",
                "priceScaleId": "right",
                "id": "spotvsperp",
                "options": {
                  "priceScaleId": "spotvsperp",
                  "visible": false,
                  "scaleMargins": {
                    "top": 0.87,
                    "bottom": 0.08
                  },
                  "negativeLineColor": "rgba(255,235,59,0)",
                  "negativeColor": "rgba(255,241,118,0.86)",
                  "positiveLineColor": "rgba(255,255,255,0.86)",
                  "baseLineVisible": false,
                  "positiveColor": "rgba(255,255,255,0.86)",
                  "lastValueVisible": true,
                  "priceLineVisible": true,
                  "topLineColor": "rgb(149,152,161)",
                  "bottomLineColor": "rgb(255,238,88)"
                },
                "series": [
                  "spotvsperp copy 1"
                ],
                "displayName": "SpotVSPerp",
                "unsavedChanges": false,
                "optionsDefinitions": {},
                "libraryId": "spotvsperp",
                "createdAt": 1700847615822,
                "updatedAt": 1714085696486
              },
              "trades": {
                "script": "plotline(cbuy+csell)",
                "id": "trades",
                "name": "trades",
                "options": {
                  "priceScaleId": "trades",
                  "scaleMargins": {
                    "top": 0.67,
                    "bottom": 0.29
                  },
                  "color": "rgba(255,255,255,0.43)",
                  "visible": false
                },
                "description": null,
                "createdAt": 1700861665246,
                "updatedAt": 1700861665246,
                "unsavedChanges": false,
                "series": [
                  "trades"
                ],
                "displayName": "trades",
                "optionsDefinitions": {}
              },
              "top-bands-spots": {
                "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n}\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\nlevels.bids.sort( (a, b) => a[0] - b[0] )\r\nlevels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nvar alpha1 = startOpacity + (1 - startOpacity) * ((levels.bids[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha1Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color1base = levels.bids[0][1] > level0 ? colorLevel0 : levels.bids[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar color1 = 'rgba(' + color1base.join(',') + ',' + alpha1Rounded + ')'\r\n\r\nvar alpha2 = startOpacity + (1 - startOpacity) * ((levels.bids[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha2Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color2base = levels.bids[1][1] > level0 ? colorLevel0 : levels.bids[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar color2 = 'rgba(' + color2base.join(',') + ',' + alpha2Rounded + ')'\r\n\r\nvar alpha3 = startOpacity + (1 - startOpacity) * ((levels.bids[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha3Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color3base = levels.bids[2][1] > level0 ? colorLevel0 : levels.bids[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar color3 = 'rgba(' + color3base.join(',') + ',' + alpha3Rounded + ')'\r\n\r\nvar alpha4 = startOpacity + (1 - startOpacity) * ((levels.bids[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha4Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color4base = levels.bids[3][1] > level0 ? colorLevel0 : levels.bids[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar color4 = 'rgba(' + color4base.join(',') + ',' + alpha4Rounded + ')'\r\n\r\nvar alpha5 = startOpacity + (1 - startOpacity) * ((levels.bids[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha5Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color5base = levels.bids[4][1] > level0 ? colorLevel0 : levels.bids[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar color5 = 'rgba(' + color5base.join(',') + ',' + alpha5Rounded + ')'\r\n\r\nif( levels.bids[0][1] > minVolume && (levels.bids[0][0] >= bottomLimit && levels.bids[0][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[0] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[0][0],\r\n      higherValue: levels.bids[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[1][1] > minVolume && (levels.bids[1][0] >= bottomLimit && levels.bids[1][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[1] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[1][0],\r\n      higherValue: levels.bids[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[2][1] > minVolume && (levels.bids[2][0] >= bottomLimit && levels.bids[2][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[2] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[2][0],\r\n      higherValue: levels.bids[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[3][1] > minVolume && (levels.bids[3][0] >= bottomLimit && levels.bids[3][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[3] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[3][0],\r\n      higherValue: levels.bids[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[4][1] > minVolume && (levels.bids[4][0] >= bottomLimit && levels.bids[4][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[4] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[4][0],\r\n      higherValue: levels.bids[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nvar alphaAsks1 = startOpacity + (1 - startOpacity) * ((levels.asks[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks1Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks1base = levels.asks[0][1] > level0 ? colorLevel0 : levels.asks[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks1 = 'rgba(' + colorAsks1base.join(',') + ',' + alphaAsks1Rounded + ')'\r\n\r\nvar alphaAsks2 = startOpacity + (1 - startOpacity) * ((levels.asks[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks2Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks2base = levels.asks[1][1] > level0 ? colorLevel0 : levels.asks[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks2 = 'rgba(' + colorAsks2base.join(',') + ',' + alphaAsks2Rounded + ')'\r\n\r\nvar alphaAsks3 = startOpacity + (1 - startOpacity) * ((levels.asks[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks3Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks3base = levels.asks[2][1] > level0 ? colorLevel0 : levels.asks[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks3 = 'rgba(' + colorAsks3base.join(',') + ',' + alphaAsks3Rounded + ')'\r\n\r\nvar alphaAsks4 = startOpacity + (1 - startOpacity) * ((levels.asks[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks4Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks4base = levels.asks[3][1] > level0 ? colorLevel0 : levels.asks[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks4 = 'rgba(' + colorAsks4base.join(',') + ',' + alphaAsks4Rounded + ')'\r\n\r\nvar alphaAsks5 = startOpacity + (1 - startOpacity) * ((levels.asks[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks5Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks5base = levels.asks[4][1] > level0 ? colorLevel0 : levels.asks[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks5 = 'rgba(' + colorAsks5base.join(',') + ',' + alphaAsks5Rounded + ')'\r\n\r\n\r\nif( levels.asks[0][1] > minVolume  && (levels.asks[0][0] >= bottomLimit && levels.asks[0][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[5] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[0][0],\r\n      higherValue: levels.asks[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[1][1] > minVolume && (levels.asks[1][0] >= bottomLimit && levels.asks[1][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[6] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[1][0],\r\n      higherValue: levels.asks[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[2][1] > minVolume && (levels.asks[2][0] >= bottomLimit && levels.asks[2][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[7] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[2][0],\r\n      higherValue: levels.asks[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[3][1] > minVolume && (levels.asks[3][0] >= bottomLimit && levels.asks[3][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[8] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[3][0],\r\n      higherValue: levels.asks[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[4][1] > minVolume && (levels.asks[4][0] >= bottomLimit && levels.asks[4][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[9] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[4][0],\r\n      higherValue: levels.asks[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nreturn\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[0][0] + moveTo, higherValue: levels.bids[0][0] + bandSize + moveTo, color: color1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[1][0] + moveTo, higherValue: levels.bids[1][0] + bandSize + moveTo, color: color2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[2][0] + moveTo, higherValue: levels.bids[2][0] + bandSize + moveTo, color: color3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[3][0] + moveTo, higherValue: levels.bids[3][0] + bandSize + moveTo, color: color4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[4][0] + moveTo, higherValue: levels.bids[4][0] + bandSize + moveTo, color: color5 } )\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[0][0] + moveTo, higherValue: levels.asks[0][0] + bandSize + moveTo, color: colorAsks1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[1][0] + moveTo, higherValue: levels.asks[1][0] + bandSize + moveTo, color: colorAsks2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[2][0] + moveTo, higherValue: levels.asks[2][0] + bandSize + moveTo, color: colorAsks3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[3][0] + moveTo, higherValue: levels.asks[3][0] + bandSize + moveTo, color: colorAsks4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[4][0] + moveTo, higherValue: levels.asks[4][0] + bandSize + moveTo, color: colorAsks5 } )",
                "name": "Top Bands Spots",
                "priceScaleId": "right",
                "id": "top-bands-spots",
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": true,
                  "colorLevels": "rgb(255,255,255)",
                  "colorLevel1": "rgba(255,255,255,0.94)",
                  "colorLevel0": "rgba(255,235,59,0.96)",
                  "colorLevel": "rgba(120,123,134,0.83)",
                  "level0": 700,
                  "level1": 400,
                  "maxVolume": 1500,
                  "minVolume": 200,
                  "startOpacity": 0.4,
                  "togglePerp": false,
                  "bandSize": 30,
                  "lastValueVisible": false,
                  "color": "rgb(76,175,80)",
                  "limitPercent": 6,
                  "priceLineVisible": false
                },
                "series": [
                  "top-bands-spots",
                  "5bidhh8k",
                  "zdz3149k",
                  "0ndg4ixg",
                  "fintf68t",
                  "lu54t4az",
                  "c4gq23xt",
                  "xryjqgbd",
                  "01ib5jjy",
                  "kplj7g43"
                ],
                "displayName": "Top Bands Spots",
                "unsavedChanges": true,
                "optionsDefinitions": {},
                "libraryId": "top-bands-spots",
                "createdAt": 1701117407838,
                "updatedAt": 1710455353789
              },
              "ob-speed": {
                "script": "obUpdates = ORDERBOOK:AGGRSPOT-BTCUSD.zupdates + ORDERBOOK:AGGRPERP-BTCUSD.zupdates\r\n\r\nplothistogram(obUpdates)\r\nline(ema(obUpdates, 21))",
                "name": "OB speed",
                "priceScaleId": "ob-speed",
                "id": "ob-speed",
                "options": {
                  "priceScaleId": "ob-speed",
                  "scaleMargins": {
                    "top": 0.62,
                    "bottom": 0.33
                  },
                  "visible": false,
                  "togglePerp": true,
                  "toggleSpot": true,
                  "priceFormat": {
                    "type": "volume",
                    "precision": 2,
                    "minMove": 0.01,
                    "auto": true
                  }
                },
                "series": [
                  "ob-speed",
                  "5lorp6k1"
                ],
                "displayName": "OB speed",
                "unsavedChanges": false,
                "preview": {},
                "createdAt": 1701126916031,
                "updatedAt": 1701165614665,
                "optionsDefinitions": {}
              },
              "alerts": {
                "script": "// markers needs a serie to get attached to\r\ncandlestick($price, color=transparent)\r\n\r\nif (markers === 0) {\r\n  // first script execution (0 is default values for all persistent variables)\r\n\r\n  // create a var to store already drawn markers\r\n  markers = []\r\n\r\n  // contain the last marker that can change as the bar update\r\n  repaintableMarker = null\r\n}\r\n\r\nif (repaintableMarker && repaintableMarker.time < time) {\r\n  // bar is +1 since active marker was added, lock it in the array\r\n  markers.push(repaintableMarker)\r\n\r\n  // free up active marker\r\n  repaintableMarker = null\r\n}\r\n\r\nvar newMarker = null\r\nvar myalert = ORDERBOOK:AGGRSPOT-BTCUSDALERTS.zalert\r\n\r\nif( myalert && myalert.length ) {\r\n  //console.log(myalert)\r\n  // big money strategy\r\n  var bearSignal = myalert[2] == 'sell'\r\n  var bullSignal = myalert[2] == 'buy'\r\n\r\n  if (bearSignal) {\r\n    var myColor5 = 'grey'\r\n    if( myalert[3] === 'strong' ){\r\n      myColor5 = 'orange'\r\n    } else if (myalert[3] === 'vstrong' ){\r\n      myColor5 = 'red'\r\n    } else if (myalert[3] === 'ultimate' ){\r\n      myColor5 = 'purple'\r\n    }\r\n    //myColor1 = myalert[3] === 'strong' ? 'red' : 'orange'\r\n\r\n    // newMarker is a temporary variable (not included in the indicator state)\r\n    // to avoid it being treated as persistent variable we wrap it inside parenthesis\r\n    (newMarker) = {\r\n      time: time,\r\n      position: 'aboveBar',\r\n      color: myColor5,\r\n      shape: 'arrowDown',\r\n    }\r\n  }\r\n\r\n  if (bullSignal) {\r\n    var myColor2 = 'grey'\r\n    if( myalert[3] === 'strong' ){\r\n      myColor2 = 'yellow'\r\n    } else if( myalert[3] === 'vstrong' ){\r\n      myColor2 = 'green'\r\n    } else if( myalert[3] === 'ultimate' ){\r\n      myColor2 = 'purple'\r\n    }\r\n\r\n    (newMarker) = {\r\n      time: time,\r\n      position: 'belowBar',\r\n      color:  myColor2,\r\n      shape: 'arrowUp',\r\n    }\r\n  }\r\n}\r\n\r\nif (newMarker || (repaintableMarker && !newMarker)) {\r\n  // override persistent variable repaintable marker\r\n  repaintableMarker = newMarker\r\n  \r\n  if (series[0].setMarkers) {\r\n    series[0].setMarkers(markers.concat(repaintableMarker))\r\n  }\r\n}",
                "name": "Alerts",
                "priceScaleId": "right",
                "id": "alerts",
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": true
                },
                "series": [
                  "alerts"
                ],
                "displayName": "Alerts",
                "unsavedChanges": false,
                "optionsDefinitions": {},
                "libraryId": "alerts",
                "createdAt": 1701316392533,
                "updatedAt": 1713306835726
              },
              "volume": {
                "script": "if (upColor === 0) {\r\n  if (options.showDelta) {\r\n    upColor = options.upBgColor\r\n    downColor = options.downBgColor\r\n  } else {\r\n    upColor = options.upColor\r\n    downColor = options.downColor\r\n  }\r\n}\r\n\r\nvar _vbuy = source(vbuy, type=perp)\r\nvar _vsell = source(vsell, type=perp)\r\n\r\nif (options.showDelta) {\r\n  plothistogram({ time: time, value: Math.abs(_vbuy-_vsell), color: _vbuy - _vsell > 0 ? options.upColor : options.downColor})\r\n}\r\n\r\nplothistogram({ time: time, value: _vbuy + _vsell, color: _vbuy > _vsell ? upColor : downColor })",
                "enabled": true,
                "name": "Volume",
                "description": "Volume + delta",
                "options": {
                  "priceScaleId": "volume",
                  "priceFormat": {
                    "type": "volume"
                  },
                  "upColor": "rgba(76,175,80,0.97)",
                  "downColor": "rgba(242,54,69,0.97)",
                  "scaleMargins": {
                    "top": 0.62,
                    "bottom": 0.3
                  },
                  "showDelta": true,
                  "upBgColor": "rgba(178,181,190,0.55)",
                  "downBgColor": "rgba(93,96,107,0.58)",
                  "visible": true,
                  "lastValueVisible": false,
                  "color": "rgba(195,168,122,0.54)",
                  "showDeltaOnly": true,
                  "showBoth": true
                },
                "id": "volume",
                "createdAt": 1700269685372,
                "updatedAt": 1701389128589,
                "series": [
                  "volume",
                  "9f0l0jv2"
                ],
                "unsavedChanges": true,
                "preview": {},
                "displayName": "Volume",
                "optionsDefinitions": {}
              },
              "top-bands-perps": {
                "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n}\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\nlevels.bids.sort( (a, b) => a[0] - b[0] )\r\nlevels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nvar alpha1 = startOpacity + (1 - startOpacity) * ((levels.bids[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha1Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color1base = levels.bids[0][1] > level0 ? colorLevel0 : levels.bids[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar color1 = 'rgba(' + color1base.join(',') + ',' + alpha1Rounded + ')'\r\n\r\nvar alpha2 = startOpacity + (1 - startOpacity) * ((levels.bids[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha2Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color2base = levels.bids[1][1] > level0 ? colorLevel0 : levels.bids[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar color2 = 'rgba(' + color2base.join(',') + ',' + alpha2Rounded + ')'\r\n\r\nvar alpha3 = startOpacity + (1 - startOpacity) * ((levels.bids[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha3Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color3base = levels.bids[2][1] > level0 ? colorLevel0 : levels.bids[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar color3 = 'rgba(' + color3base.join(',') + ',' + alpha3Rounded + ')'\r\n\r\nvar alpha4 = startOpacity + (1 - startOpacity) * ((levels.bids[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha4Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color4base = levels.bids[3][1] > level0 ? colorLevel0 : levels.bids[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar color4 = 'rgba(' + color4base.join(',') + ',' + alpha4Rounded + ')'\r\n\r\nvar alpha5 = startOpacity + (1 - startOpacity) * ((levels.bids[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha5Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color5base = levels.bids[4][1] > level0 ? colorLevel0 : levels.bids[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar color5 = 'rgba(' + color5base.join(',') + ',' + alpha5Rounded + ')'\r\n\r\nif( levels.bids[0][1] > minVolume && (levels.bids[0][0] >= bottomLimit && levels.bids[0][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[0] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[0][0],\r\n      higherValue: levels.bids[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[1][1] > minVolume && (levels.bids[1][0] >= bottomLimit && levels.bids[1][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[1] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[1][0],\r\n      higherValue: levels.bids[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[2][1] > minVolume && (levels.bids[2][0] >= bottomLimit && levels.bids[2][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[2] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[2][0],\r\n      higherValue: levels.bids[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[3][1] > minVolume && (levels.bids[3][0] >= bottomLimit && levels.bids[3][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[3] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[3][0],\r\n      higherValue: levels.bids[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[4][1] > minVolume && (levels.bids[4][0] >= bottomLimit && levels.bids[4][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[4] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[4][0],\r\n      higherValue: levels.bids[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nvar alphaAsks1 = startOpacity + (1 - startOpacity) * ((levels.asks[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks1Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks1base = levels.asks[0][1] > level0 ? colorLevel0 : levels.asks[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks1 = 'rgba(' + colorAsks1base.join(',') + ',' + alphaAsks1Rounded + ')'\r\n\r\nvar alphaAsks2 = startOpacity + (1 - startOpacity) * ((levels.asks[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks2Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks2base = levels.asks[1][1] > level0 ? colorLevel0 : levels.asks[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks2 = 'rgba(' + colorAsks2base.join(',') + ',' + alphaAsks2Rounded + ')'\r\n\r\nvar alphaAsks3 = startOpacity + (1 - startOpacity) * ((levels.asks[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks3Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks3base = levels.asks[2][1] > level0 ? colorLevel0 : levels.asks[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks3 = 'rgba(' + colorAsks3base.join(',') + ',' + alphaAsks3Rounded + ')'\r\n\r\nvar alphaAsks4 = startOpacity + (1 - startOpacity) * ((levels.asks[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks4Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks4base = levels.asks[3][1] > level0 ? colorLevel0 : levels.asks[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks4 = 'rgba(' + colorAsks4base.join(',') + ',' + alphaAsks4Rounded + ')'\r\n\r\nvar alphaAsks5 = startOpacity + (1 - startOpacity) * ((levels.asks[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks5Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks5base = levels.asks[4][1] > level0 ? colorLevel0 : levels.asks[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks5 = 'rgba(' + colorAsks5base.join(',') + ',' + alphaAsks5Rounded + ')'\r\n\r\n\r\nif( levels.asks[0][1] > minVolume  && (levels.asks[0][0] >= bottomLimit && levels.asks[0][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[5] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[0][0],\r\n      higherValue: levels.asks[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[1][1] > minVolume && (levels.asks[1][0] >= bottomLimit && levels.asks[1][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[6] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[1][0],\r\n      higherValue: levels.asks[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[2][1] > minVolume && (levels.asks[2][0] >= bottomLimit && levels.asks[2][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[7] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[2][0],\r\n      higherValue: levels.asks[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[3][1] > minVolume && (levels.asks[3][0] >= bottomLimit && levels.asks[3][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[8] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[3][0],\r\n      higherValue: levels.asks[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[4][1] > minVolume && (levels.asks[4][0] >= bottomLimit && levels.asks[4][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[9] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[4][0],\r\n      higherValue: levels.asks[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nreturn\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[0][0] + moveTo, higherValue: levels.bids[0][0] + bandSize + moveTo, color: color1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[1][0] + moveTo, higherValue: levels.bids[1][0] + bandSize + moveTo, color: color2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[2][0] + moveTo, higherValue: levels.bids[2][0] + bandSize + moveTo, color: color3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[3][0] + moveTo, higherValue: levels.bids[3][0] + bandSize + moveTo, color: color4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[4][0] + moveTo, higherValue: levels.bids[4][0] + bandSize + moveTo, color: color5 } )\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[0][0] + moveTo, higherValue: levels.asks[0][0] + bandSize + moveTo, color: colorAsks1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[1][0] + moveTo, higherValue: levels.asks[1][0] + bandSize + moveTo, color: colorAsks2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[2][0] + moveTo, higherValue: levels.asks[2][0] + bandSize + moveTo, color: colorAsks3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[3][0] + moveTo, higherValue: levels.asks[3][0] + bandSize + moveTo, color: colorAsks4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[4][0] + moveTo, higherValue: levels.asks[4][0] + bandSize + moveTo, color: colorAsks5 } )",
                "name": "Top Bands Perps",
                "priceScaleId": "right",
                "id": "top-bands-perps",
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": true,
                  "colorLevels": "rgb(255,255,255)",
                  "colorLevel1": "rgba(41,98,255,0.91)",
                  "colorLevel0": "rgb(242,54,69)",
                  "colorLevel": "rgba(91,156,246,0.79)",
                  "level0": 1900,
                  "level1": 1600,
                  "maxVolume": 3500,
                  "minVolume": 600,
                  "startOpacity": 0.3,
                  "togglePerp": true,
                  "bandSize": 25,
                  "limitPercent": 5,
                  "priceLineVisible": false,
                  "baseLineVisible": false
                },
                "series": [
                  "top-bands-perps",
                  "htfbbpc7",
                  "rqypatuz",
                  "ak1l3tsk",
                  "lqervo0h",
                  "dz3hrshv",
                  "9a7mzxuw",
                  "skre810o",
                  "v5z5f1l8",
                  "52uf9fti"
                ],
                "displayName": "Top Bands Perps",
                "unsavedChanges": true,
                "optionsDefinitions": {},
                "libraryId": "top-bands-perps",
                "createdAt": 1702374821392,
                "updatedAt": 1710455365119
              },
              "overlays-all": {
                "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    lastIndex = null\r\n    pendingMarkers = []\r\n    spotColor = options.spotColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    perpColor = options.perpColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    binanceColor = options.binanceColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    coinbaseColor = options.coinbaseColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    bitmexColor = options.bitmexColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1, 5).map(a => +a);\r\n\r\n    //allOnColor = options.allOnColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    spotOpacity = spotColor.pop()\r\n    perpOpacity = perpColor.pop()\r\n    binanceOpacity = binanceColor.pop()\r\n    coinbaseOpacity = coinbaseColor.pop()\r\n    bitmexOpacity = bitmexColor.pop()\r\n   // allOnColorOpacity = allOnColor.pop()\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n  \r\n    spotBuyAlerts  = [40, 63, 46, 60]\r\n    spotSellAlerts = [-40, -63, -46, -60]\r\n\r\n    perpBuyAlerts  = [37, 27, 36, 35]\r\n    perpSellAlerts = [-20, -27, -36, -35]\r\n\r\n    binanceBuyAlerts  = [70, 70, 70, 70]\r\n    binanceSellAlerts = [-70, -70, -70, -70]\r\n\r\n    coinbaseBuyAlerts  = [50, 50, 50, 50]\r\n    coinbaseSellAlerts = [-50, -70, -65, -50]\r\n\r\n    bitmexBuyAlerts  = [-50, -60, -50, -50]\r\n    bitmexSellAlerts = [-50, -60, -50, -50]\r\n\r\n    alerts = {\r\n      spot: {\r\n        buy: spotBuyAlerts,\r\n        sell: spotSellAlerts\r\n      },\r\n      perp: {\r\n        buy: perpBuyAlerts,\r\n        sell: perpSellAlerts\r\n      },\r\n      binance: {\r\n        buy: binanceBuyAlerts,\r\n        sell: binanceSellAlerts\r\n      },\r\n      coinbase: {\r\n        buy: coinbaseBuyAlerts,\r\n        sell: coinbaseSellAlerts\r\n      },\r\n        bitmex: {\r\n            buy: bitmexBuyAlerts,\r\n            sell: bitmexSellAlerts\r\n        }\r\n    }\r\n\r\n    whichColors = {\r\n      spot: spotColor,\r\n      perp: perpColor,\r\n      binance: binanceColor,\r\n      coinbase: coinbaseColor,\r\n      bitmex: bitmexColor\r\n    }\r\n\r\n    allOnIndicator = options.toggleAllOnIndicator || false,\r\n    allOnMinusOne = options.toggleAllOnMinusOne || false,\r\n\r\n    showType = {\r\n      spot: options.toggleSpot,\r\n      perp: options.togglePerp,\r\n      binance: options.toggleBinance,\r\n      coinbase: options.toggleCoinbase,\r\n      bitmex: options.toggleBitmex\r\n    }\r\n\r\n    showBand = [\r\n        options.toggleBand1 || false,\r\n        options.toggleBand2 || false,\r\n        options.toggleBand3 || false,\r\n        options.toggleBand4 || false,\r\n    ]\r\n\r\n    bitmexSmallerBand = options.toggleBitmexSmallerBand || false\r\n\r\n    lowerPercent = [options.band0lowerPercent || 0.11, 1, 2.5, 5]\r\n    upperPercent = [1, 2.5, 5, 10]  \r\n\r\n  }\r\n  // </STARTUP SCRIPT> \r\n\r\n// process only on new candle\r\nif (bar.length === lastIndex) {\r\n  return\r\n}\r\n\r\n  var ratiosPerp = ORDERBOOK:AGGRPERP-BTCUSD.zratios\r\n  var ratiosSpot = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\n  var ratiosBinance = renderer.sources['ORDERBOOK:BINANCE-BTCUSDT'] && renderer.sources['ORDERBOOK:BINANCE-BTCUSDT'].zratios\r\n  var ratiosCoinbase = renderer.sources['ORDERBOOK:COINBASE-BTCUSD'] && renderer.sources['ORDERBOOK:COINBASE-BTCUSD'].zratios \r\n  var ratiosBitmex = renderer.sources['ORDERBOOK:BITMEX-XBTUSD'] && renderer.sources['ORDERBOOK:BITMEX-XBTUSD'].zratios\r\n\r\n  var m = [\r\n      { which: 'perp', ratios: ratiosPerp || [], bands: [] },\r\n      { which: 'spot', ratios: ratiosSpot || [], bands: [] },\r\n      { which: 'binance', ratios: ratiosBinance || [], bands: [] },\r\n      { which: 'coinbase', ratios: ratiosCoinbase || [], bands: [] },\r\n      { which: 'bitmex', ratios: ratiosBitmex || [], bands: [] }\r\n  ];\r\n\r\n  // for each ratio\r\n  for(let ratioIndex = 0; ratioIndex < 4; ratioIndex++){\r\n\r\n    // TODO must be same direction\r\n    var allOn = true;\r\n    var allowMinusOne = allOnMinusOne;\r\n\r\n    // for each type (perp, spot, binance, ...)\r\n    for(let typeIndex = 0; typeIndex < m.length; typeIndex++){\r\n\r\n      var c = m[typeIndex]\r\n\r\n      if( showBand[ratioIndex] === false || showType[c.which]  === false ){\r\n        c.bands.push([0, 0, '']) \r\n        continue\r\n      }\r\n        \r\n      var ratio = c.ratios.length && c.ratios[ratioIndex]\r\n      var direction = Math.sign(ratio)\r\n      var buyAlert = alerts[c.which]['buy'][ratioIndex]\r\n      var sellAlert = alerts[c.which]['sell'][ratioIndex]\r\n      var threshold = direction > 0 ? buyAlert : sellAlert\r\n      var thresholdAbs = Math.abs(threshold)\r\n    \r\n      var smaller = bitmexSmallerBand && c.which === 'bitmex' ? 2000 : 0;\r\n      var lower = $price.close + -1 * direction * (($price.close  * lowerPercent[ratioIndex]) / 100) + direction * smaller \r\n      var upper = $price.close + -1 * direction * (($price.close  * upperPercent[ratioIndex]) / 100) + direction * smaller \r\n\r\n      if( !ratio || Math.abs(ratio) < thresholdAbs ){\r\n          allOn = allowMinusOne ? true : false\r\n          allowMinusOne = false\r\n          c.bands.push([0, 0, '']) \r\n      }else{\r\n\r\n          var alphaRatio = Math.abs(ratio) < thresholdAbs ? 0 : startOpacity + (1 - startOpacity) * ((Math.abs(ratio) - thresholdAbs) / (100 - thresholdAbs))\r\n          var alphaRatioRounded = Math.round(alphaRatio * 100) / 100 \r\n          var colorRatio = 'rgba(' + whichColors[c.which].join(',') + ',' + alphaRatioRounded + ')'\r\n          \r\n          c.bands.push([lower, upper, colorRatio])\r\n      }\r\n      \r\n    }// end for each type\r\n\r\n    if( allOnIndicator && allOn ){\r\n      for(let typeIndex = 0; typeIndex < 4; typeIndex++){\r\n        var c = m[typeIndex]\r\n        c.bands[ratioIndex] = [lower, upper, options.allOnColor]\r\n      }\r\n    }\r\n\r\n  } // end for each ratios\r\n\r\n\r\nvar i = 0\r\n\r\nfor(let ratioIndex = 0; ratioIndex < 4; ratioIndex++){\r\n\r\n    if( showBand[ratioIndex] === false ){\r\n      i = i + m.length\r\n      continue\r\n    }\r\n\r\n    for(let typeIndex = 0; typeIndex < m.length; typeIndex++){\r\n\r\n       var c = m[typeIndex]\r\n       \r\n       if( c.bands.length && c.bands[ratioIndex][0] !== 0 ) {\r\n         renderer.indicators[indicatorId].series[i] = {\r\n          time: time, \r\n          lowerValue: c.bands[ratioIndex][0],\r\n          higherValue: c.bands[ratioIndex][1],\r\n          color:  c.bands[ratioIndex][2]\r\n        }\r\n      }\r\n\r\n      i++\r\n    }\r\n}\r\n\r\n// set reference to bar index : avoid process next tick\r\nlastIndex = bar.length\r\n\r\nreturn\r\n//perp\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })     \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })   \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })   \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\n            brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })",
                "name": "Overlays All",
                "priceScaleId": "right",
                "id": "overlays-all",
                "options": {
                  "priceScaleId": "right",
                  "startOpacity": "",
                  "toggleAllOnIndicator": true,
                  "toggleSpot": true,
                  "togglePerp": true,
                  "toggleBinance": true,
                  "toggleCoinbase": true,
                  "toggleBitmex": true,
                  "toggleBand1": true,
                  "toggleBand2": true,
                  "toggleBand3": true,
                  "toggleBand4": true,
                  "spotColor": "rgb(255,235,59)",
                  "perpColor": "rgb(41,98,255)",
                  "binanceColor": "rgb(255,255,255)",
                  "coinbaseColor": "rgb(250,161,164)",
                  "bitmexColor": "rgb(171,71,188)",
                  "allOnColor": "rgb(242,54,69)",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "band0lowerPercent": null,
                  "visible": true,
                  "toggleBitmexSmallerBand": false,
                  "allOnMinusOne": null,
                  "toggleAllOnMinusOne": false
                },
                "optionsDefinitions": {},
                "series": [
                  "overlays-all",
                  "trn5busm",
                  "7ff4vvhv",
                  "s88yy9hg",
                  "w7wxw2r7",
                  "yibf0htx",
                  "tvjf8ldm",
                  "6ujjoven",
                  "4rfvy26b",
                  "804tbkz4",
                  "4qrgkljn",
                  "1mcfq793",
                  "1p6itawm",
                  "0pzqvxzr",
                  "jgus7qyo",
                  "vva4qf76",
                  "hibayosa",
                  "qsfwiu5m",
                  "ng37uoni",
                  "6k04czht"
                ],
                "displayName": "Overlays All",
                "unsavedChanges": true,
                "libraryId": "overlays-all",
                "createdAt": 1703209928644,
                "updatedAt": 1713657464427
              },
              "averages": {
                "script": "var price = (BINANCE_FUTURES:btcusdt.high + BINANCE_FUTURES:btcusdt.low + BINANCE_FUTURES:btcusdt.close) / 3\r\nvar sumPV = sum((BINANCE_FUTURES:btcusdt.vsell + BINANCE_FUTURES:btcusdt.vbuy) * (BINANCE_FUTURES:btcusdt.high + BINANCE_FUTURES:btcusdt.low + BINANCE_FUTURES:btcusdt.close) / 3 , options.vwmaLength)\r\nvar sumV = sum((BINANCE_FUTURES:btcusdt.vsell + BINANCE_FUTURES:btcusdt.vbuy), options.vwmaLength)\r\n\r\nline(ema(price, options.emaLength))\r\n\r\nline(sumPV / sumV, color = options.vwmaColor)",
                "name": "Averages",
                "priceScaleId": "right",
                "id": "averages",
                "options": {
                  "priceScaleId": "right",
                  "color": "rgba(178,40,51,0.5)",
                  "vwma": null,
                  "vwmaColor": "rgba(251,192,45,0.75)",
                  "visible": true,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "vwmaLength": 21,
                  "emaLength": 121
                },
                "optionsDefinitions": {},
                "series": [
                  "averages",
                  "redahn5b"
                ],
                "displayName": "Averages",
                "unsavedChanges": true
              },
              "bollinger-bands": {
                "script": "var a = sma(Math.pow($price.close,2),options.length)\nvar b = Math.pow(sum($price.close,options.length),2)/Math.pow(options.length,2)\nvar stdev = Math.sqrt(a - b)\nvar src = $price.close\n\nvar basis = sma($price.close, options.length)\nvar dev = options.mult * stdev\nupper = basis + dev\nlower = basis - dev\n\nplotline(basis, color=options.basisColor)\nplotcloudarea(lower, upper)",
                "id": "bollinger-bands",
                "name": "Bollinger Bands",
                "options": {
                  "priceScaleId": "right",
                  "mult": 3,
                  "length": 120,
                  "lineStyle": 2,
                  "basisColor": "rgba(129,199,132,0.5)",
                  "positiveColor": "rgba(0,0,0,0.1)",
                  "negativeColor": "rgba(0,0,0,0.1)",
                  "lowerLineColor": "rgb(129,199,132)",
                  "higherLineColor": "rgb(129,199,132)",
                  "priceLineVisible": false,
                  "lastValueVisible": true,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": false
                },
                "description": null,
                "createdAt": 1683892675452,
                "updatedAt": 1705183212240,
                "unsavedChanges": false,
                "optionsDefinitions": {},
                "series": [
                  "bollinger-bands",
                  "9p3scg97"
                ],
                "displayName": "Bollinger Bands",
                "libraryId": "bollinger-bands"
              },
              "_f8i6stuml3q7zwkc": {
                "id": "_f8i6stuml3q7zwkc",
                "libraryId": "cvd-binance",
                "name": "CVD Binance",
                "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
                "createdAt": 1705025291244,
                "updatedAt": 1706057087744,
                "options": {
                  "priceScaleId": "_v9ix9ggm0looumtf",
                  "scaleMargins": {
                    "top": 0.04,
                    "bottom": 0.8
                  },
                  "bodyPercentWatch": null,
                  "wickRatioThreshold": null,
                  "toggleDebug": null,
                  "toggleVolumeWick": null,
                  "togglePrintNormalObv": null,
                  "toggleRefine": null,
                  "showDivs": true,
                  "pivotLeftLength": 50,
                  "pivotRightLength": 50,
                  "ppCheck": 3,
                  "maxbars": null,
                  "togglePivotAgo": false,
                  "toggleShowPricePivot": false,
                  "DivcolorUp": "rgb(255,238,88)",
                  "DivcolorDn": "rgb(255,238,88)",
                  "cvdColor": "rgb(255,235,59)",
                  "quote": 0,
                  "exchange": "BINANCE",
                  "type": "spot",
                  "title": "S",
                  "visible": true
                },
                "optionsDefinitions": {
                  "quote": {
                    "default": 0,
                    "type": "list",
                    "options": [
                      null,
                      "USD",
                      "USDT",
                      "TUSD",
                      "USDC"
                    ],
                    "rebuild": true
                  },
                  "exchange": {
                    "default": 0,
                    "type": "exchange",
                    "rebuild": true
                  },
                  "type": {
                    "default": "perp",
                    "type": "list",
                    "options": [
                      null,
                      "spot",
                      "perp"
                    ],
                    "rebuild": true
                  }
                },
                "series": [
                  "cvd-binance",
                  "067unsl2"
                ],
                "displayName": "CVD Binance",
                "unsavedChanges": false
              },
              "_pngsl31b0gpvtuas": {
                "id": "_pngsl31b0gpvtuas",
                "libraryId": "cvd-coinbase copy 1",
                "name": "CVD Coinbase",
                "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
                "createdAt": 1705025338594,
                "updatedAt": 1710054922560,
                "options": {
                  "priceScaleId": "cvd-binance-spot",
                  "scaleMargins": {
                    "top": 0.04,
                    "bottom": 0.8
                  },
                  "bodyPercentWatch": null,
                  "wickRatioThreshold": null,
                  "toggleDebug": null,
                  "toggleVolumeWick": null,
                  "togglePrintNormalObv": null,
                  "toggleRefine": null,
                  "showDivs": true,
                  "pivotLeftLength": 50,
                  "pivotRightLength": 50,
                  "ppCheck": 3,
                  "maxbars": null,
                  "togglePivotAgo": false,
                  "toggleShowPricePivot": false,
                  "DivcolorUp": "rgb(247,124,128)",
                  "DivcolorDn": "rgb(247,124,128)",
                  "cvdColor": "rgb(247,124,128)",
                  "quote": 0,
                  "exchange": "COINBASE",
                  "type": "spot",
                  "title": "C",
                  "color": "rgb(250,161,164)",
                  "visible": true
                },
                "optionsDefinitions": {
                  "quote": {
                    "default": 0,
                    "type": "list",
                    "options": [
                      null,
                      "USD",
                      "USDT",
                      "TUSD",
                      "USDC"
                    ],
                    "rebuild": true
                  },
                  "exchange": {
                    "default": 0,
                    "type": "exchange",
                    "rebuild": true
                  },
                  "type": {
                    "default": "perp",
                    "type": "list",
                    "options": [
                      null,
                      "spot",
                      "perp"
                    ],
                    "rebuild": true
                  }
                },
                "series": [
                  "cvd-coinbase copy 1",
                  "sbcnrlrc"
                ],
                "displayName": "CVD Coinbase",
                "unsavedChanges": false
              },
              "_bc6lfhgxb0wc36l9": {
                "id": "_bc6lfhgxb0wc36l9",
                "libraryId": "cvd-binance-p",
                "name": "CVD Binance P",
                "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
                "createdAt": 1705025447976,
                "updatedAt": 1711424254003,
                "options": {
                  "priceScaleId": "_bc6lfhgxb0wc36l9",
                  "scaleMargins": {
                    "top": 0.04,
                    "bottom": 0.8
                  },
                  "bodyPercentWatch": null,
                  "wickRatioThreshold": null,
                  "toggleDebug": null,
                  "toggleVolumeWick": null,
                  "togglePrintNormalObv": null,
                  "toggleRefine": null,
                  "showDivs": true,
                  "pivotLeftLength": 25,
                  "pivotRightLength": 25,
                  "ppCheck": 3,
                  "maxbars": null,
                  "togglePivotAgo": true,
                  "toggleShowPricePivot": false,
                  "DivcolorUp": "rgb(49,121,245)",
                  "DivcolorDn": "rgb(49,121,245)",
                  "cvdColor": "rgb(49,121,245)",
                  "quote": 0,
                  "exchange": "BINANCE_FUTURES",
                  "type": "perp",
                  "title": "P"
                },
                "optionsDefinitions": {
                  "quote": {
                    "default": 0,
                    "type": "list",
                    "options": [
                      null,
                      "USD",
                      "USDT",
                      "TUSD",
                      "USDC"
                    ],
                    "rebuild": true
                  },
                  "exchange": {
                    "default": 0,
                    "type": "exchange",
                    "rebuild": true
                  },
                  "type": {
                    "default": "perp",
                    "type": "list",
                    "options": [
                      null,
                      "spot",
                      "perp"
                    ],
                    "rebuild": true
                  }
                },
                "series": [
                  "cvd-binance-p",
                  "x56zes9e"
                ],
                "displayName": "CVD Binance P",
                "unsavedChanges": true
              },
              "_oh4jdeuqr3sfb21e": {
                "id": "_oh4jdeuqr3sfb21e",
                "libraryId": "keltner",
                "name": "keltner",
                "description": null,
                "script": "close = BINANCE_FUTURES:btcusdt.close\n\nrange = BINANCE_FUTURES:btcusdt.high - BINANCE_FUTURES:btcusdt.low\naverageRange = sma(range, options.length)\n\nbasis = ema(close, options.length)\ndev = options.mult * averageRange\nupper = basis + dev\nlower = basis - dev\n\nplotline(basis, color=options.basisColor)\nplotcloudarea(lower, upper)",
                "createdAt": 1666924136794,
                "updatedAt": 1705183470830,
                "options": {
                  "priceScaleId": "right",
                  "length": 30,
                  "mult": 4,
                  "positiveColor": "rgba(35,37,35,0.1)",
                  "negativeColor": "rgba(192,174,174,0.1)",
                  "higherLineColor": "rgba(137,141,138,0.25)",
                  "lowerLineColor": "rgba(223,210,210,0.16)",
                  "basisColor": "rgba(228,224,218,0.34)",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": false
                },
                "optionsDefinitions": {},
                "series": [
                  "keltner",
                  "942va4rh"
                ],
                "displayName": "keltner",
                "unsavedChanges": false
              },
              "_my4zvk49em6mh062": {
                "id": "_my4zvk49em6mh062",
                "libraryId": "oi",
                "name": "OI",
                "script": "src = { sources: { \"ORDERBOOK:AGGROI-BTCUSD\":ORDERBOOK:AGGROI-BTCUSD }, localTimestamp: time }\r\n\r\nvar ohlc = options.useHeikinAshi ? avg_heikinashi(src) : options.useGaps ? avg_ohlc_with_gaps(src) : avg_ohlc(src)\r\n\r\nplotcandlestick(ohlc, id=openinterest)",
                "createdAt": 1705463203632,
                "updatedAt": 1713247810872,
                "options": {
                  "priceScaleId": "_tdqicpndr092c1gk",
                  "priceFormat": {
                    "type": "volume",
                    "precision": 2,
                    "minMove": 0.01,
                    "auto": true
                  },
                  "priceLineVisible": true,
                  "lastValueVisible": true,
                  "borderVisible": false,
                  "upColor": "rgba(255,235,59,0.52)",
                  "downColor": "rgba(242,54,69,0.64)",
                  "borderUpColor": "rgba(255,245,157,0.66)",
                  "borderDownColor": "rgba(178,40,51,0.52)",
                  "wickUpColor": "rgb(223,211,144)",
                  "wickDownColor": "rgba(239,67,82,0.47)",
                  "useGaps": false,
                  "useHeikinAshi": false,
                  "scaleMargins": {
                    "top": 0.21,
                    "bottom": 0.69
                  },
                  "visible": true
                },
                "optionsDefinitions": {},
                "series": [
                  "openinterest"
                ],
                "displayName": "OI",
                "unsavedChanges": false
              },
              "_7o282jzm9vulptiq": {
                "id": "_7o282jzm9vulptiq",
                "libraryId": "liquidation-heatmap copy 1",
                "name": "Liquidation Heatmap",
                "description": "Visualizes potential liquidation levels",
                "script": "leverages = option(default=5|20|100,type=text)\nthreshold = option(default=800,type=range,min=100,max=5000,log=true, step=100)\nmaxRange = option(default=2200,type=range,min=100,max=5000,log=true, step=100)\nfadeOut = option(default=0,type=range,min=0,max=1,log=true,step=0.001)\nstepScale = option(default=0.5,type=range,min=0,max=2,step=0.01)\nstepValue = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=50,type=range,min=0,max=100,step=1,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\nsrc = option(default=\"high/low\",type=list,options=[\"open\", \"high\", \"low\", \"close\",\"hl2\",\"ohl3\",\"ohlc4\",\"hlcc4\",\"high/low\",\"low/high\"])\ncolor0 = option(default=rgba(0,0,0,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=20,type=range,min=1,max=200, step=1)\natrLength = option(default=20,type=range,min=1,max=200, step=1)\nuseHK = option(default=true,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=true,type=checkbox)\ndynamicMax = option(default=true,type=checkbox)\nstrokeWidth = option(default=0,type=number,description=\"For debug purpose\")\n\n//var isLastCurrentCandle = new Date().getTime() >= renderer.timestamp && new Date().getTime() <= renderer.timestamp + renderer.timescale;\n\n\nif (!liquidityAtPrices) {\n  // init\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  resistances = []\n  supports = []\n  pendingRedraws = []\n  maxOpened = 0 \n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // bind boundaries reference\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n   return\n}\n\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\npriceRef = price\n\n// grid size\nif (stepValue) {\n  // absolute\n  steps = stepValue\n} else {\n  // calculated with atr\n  var hl = price.high - price.low\n  var hc = Math.abs(price.high - priceRef[1].close)\n  var lc = Math.abs(price.low - priceRef[1].close)\n  var atr = sma(Math.max(hl, hc, lc), atrLength)\n\n  if (bar.length < atrLength) {\n    return\n  }\n\n  if (!steps) {\n    steps = atr * stepScale\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\noi = $openinterest\nvar oiDelta = oi.high - oi.low\n\nvol = buyVolume + sellVolume\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\n\n// custom src\nvar resolvedSrc  = priceRef[1][options.src]\nif (resolvedSrc === undefined) {\n  if (options.src === 'hl2') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low) / 2\n  } else if (options.src === 'ohl3') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low) / 3\n  } else if (options.src === 'ohlc4') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (options.src === 'hlcc4') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low + priceRef[1].close + priceRef[1].close) / 4\n  }\n}\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  if (options.src === 'high/low') {\n    resolvedSrc = lev > 0 ? priceRef[1].high : priceRef[1].low\n  } else if (options.src === 'low/high') {\n    resolvedSrc = lev > 0 ? priceRef[1].low : priceRef[1].high\n  }\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  var lp = (resolvedSrc + resolvedSrc * (100 / lev / 100))\n  \n  // rounded lp median (the cell id)\n  var slp = Math.ceil(lp / steps) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      count: 0,\n      top: top,\n      bottom: bottom\n    }\n    \n    if (lev > 0) {\n        resistances.push(slp)\n        resistances.sort((a, b) => a - b)\n    } else {\n        supports.push(slp)\n        supports.sort((a, b) => b - a)\n    }\n  }\n  \n  // update cell\n  //liquidityAtPrices[slp].count++\n  //liquidityAtPrices[slp].strength += lev > 0 ? sellRatio : buyRatio\n  \n  //var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  if (oiDelta < 0) {\n    continue\n  }\n  var oiDeltaNormalized = oiDelta / options.threshold\n  var maxOpenedThreshold = dynamicMax && maxOpened > 0 ? maxOpened : options.maxRange\n  var ratio = Math.min(1, (liquidityAtPrices[slp].strength + oiDelta) / maxOpenedThreshold ) * (options.strength / 100)\n  // var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  liquidityAtPrices[slp].count++\n  liquidityAtPrices[slp].strength += oiDelta\n  //ratio = liquidityAtPrices[slp].strength > 0 ? 1 : 0.1\n  liquidityAtPrices[slp].color = interpolate(ratio, color0, color1, color2, color3)\n\n  if (liquidityAtPrices[slp].strength > options.threshold ) {\n    maxOpened = maxOpened > liquidityAtPrices[slp].strength ? maxOpened : liquidityAtPrices[slp].strength\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.push(slp)\n    }\n  }\n}\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length\n      }\n      \n      \n\n      cell.id = Math.random().toString()\n      renderer.indicators[indicatorId].series[usedIndex] ={\n        id: cell.id,\n        time: time,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: cell.color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  if (\n   price.low <= supports[i] || liquidityAtPrices[supports[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[supports[i]].id] = bar.length\n    delete liquidityAtPrices[supports[i]]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[supports[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  if (\n   price.high >= resistances[i] || liquidityAtPrices[resistances[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[resistances[i]].id] = bar.length\n    delete liquidityAtPrices[resistances[i]]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[resistances[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define available series\nif (renderer.indicators[indicatorId].series[0]) {\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[1]) {\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[2]) {\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[3]) {\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[4]) {\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[5]) {\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[6]) {\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[7]) {\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[8]) {\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[9]) {\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[10]) {\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[11]) {\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[12]) {\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[13]) {\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[14]) {\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[15]) {\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[16]) {\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}",
                "createdAt": 1703543399433,
                "updatedAt": 1713475074380,
                "options": {
                  "priceScaleId": "right",
                  "leverages": "50|100",
                  "threshold": 800,
                  "fadeOut": 0,
                  "stepScale": 0.52,
                  "stepValue": 50,
                  "strength": 78,
                  "quote": "USDT",
                  "exchange": "BINANCE_FUTURES",
                  "type": "perp",
                  "src": "high/low",
                  "volLength": 21,
                  "atrLength": 22,
                  "useHK": false,
                  "useLog": true,
                  "strokeWidth": 0,
                  "color0": "rgba(194,24,91,0)",
                  "color": "rgba(76,175,80,0)",
                  "visible": true,
                  "lastValueVisible": false,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "max": 100,
                  "color1": "rgba(63,16,87,0.79)",
                  "color2": "rgba(76,152,134,0.79)",
                  "maxRange": 4200,
                  "dynamicMax": false
                },
                "optionsDefinitions": {
                  "leverages": {
                    "default": "5|20|100",
                    "type": "text"
                  },
                  "threshold": {
                    "default": 800,
                    "type": "range",
                    "min": 100,
                    "max": 5000,
                    "log": true,
                    "step": 100
                  },
                  "maxRange": {
                    "default": 2200,
                    "type": "range",
                    "min": 100,
                    "max": 5000,
                    "log": true,
                    "step": 100
                  },
                  "fadeOut": {
                    "default": 0,
                    "type": "range",
                    "min": 0,
                    "max": 1,
                    "log": true,
                    "step": 0.001
                  },
                  "stepScale": {
                    "default": 0.5,
                    "type": "range",
                    "min": 0,
                    "max": 2,
                    "step": 0.01
                  },
                  "stepValue": {
                    "default": "",
                    "type": "text",
                    "placeholder": "empty = ATR"
                  },
                  "strength": {
                    "default": 50,
                    "type": "range",
                    "min": 0,
                    "max": 100,
                    "step": 1,
                    "log": true
                  },
                  "quote": {
                    "default": 0,
                    "type": "list",
                    "options": [
                      null,
                      "USD",
                      "USDT",
                      "TUSD",
                      "USDC"
                    ],
                    "rebuild": true
                  },
                  "exchange": {
                    "default": 0,
                    "type": "exchange",
                    "rebuild": true
                  },
                  "type": {
                    "default": "perp",
                    "type": "list",
                    "options": [
                      null,
                      "spot",
                      "perp"
                    ],
                    "rebuild": true
                  },
                  "src": {
                    "default": "high/low",
                    "type": "list",
                    "options": [
                      "open",
                      "high",
                      "low",
                      "close",
                      "hl2",
                      "ohl3",
                      "ohlc4",
                      "hlcc4",
                      "high/low",
                      "low/high"
                    ]
                  },
                  "color0": {
                    "default": "rgba(0,0,0,0)",
                    "type": "color"
                  },
                  "color1": {
                    "default": "rgb(63,16,87)",
                    "type": "color"
                  },
                  "color2": {
                    "default": "rgb(76,152,134)",
                    "type": "color"
                  },
                  "color3": {
                    "default": "rgb(240,218,24)",
                    "type": "color"
                  },
                  "volLength": {
                    "default": 20,
                    "type": "range",
                    "min": 1,
                    "max": 200,
                    "step": 1
                  },
                  "atrLength": {
                    "default": 20,
                    "type": "range",
                    "min": 1,
                    "max": 200,
                    "step": 1
                  },
                  "useHK": {
                    "default": true,
                    "type": "checkbox",
                    "description": "Use heikinashi as source"
                  },
                  "useLog": {
                    "default": true,
                    "type": "checkbox"
                  },
                  "dynamicMax": {
                    "default": true,
                    "type": "checkbox"
                  },
                  "strokeWidth": {
                    "default": 0,
                    "type": "number",
                    "description": "For debug purpose"
                  }
                },
                "series": [
                  "liquidation-heatmap copy 2",
                  "z9498ogg",
                  "65ffaei8",
                  "l1ed6rdj",
                  "i83qlokf",
                  "kd9giwzt",
                  "59ca2z5h",
                  "ggp8zrhu",
                  "zeujgpj0",
                  "qkzoy2hu",
                  "4drcilyx",
                  "i8bg5d0r",
                  "0m36lr78",
                  "bm3jaidb",
                  "bpmm00ga",
                  "4x7wdr0p",
                  "4fpui2q9"
                ],
                "displayName": "Liquidation Heatmap",
                "unsavedChanges": true,
                "lastPreset": null
              },
              "_6fov3tmuy13lvmmv": {
                "id": "_6fov3tmuy13lvmmv",
                "libraryId": "liquidation-heatmap-copy-1",
                "name": "Liquidation Heatmap copy 1",
                "description": "Visualizes potential liquidation levels",
                "script": "leverages = option(default=5|20|100,type=text)\nthreshold = option(default=0,type=range,min=0,max=220,log=true)\nfadeOut = option(default=0,type=range,min=0,max=1,log=true,step=0.001)\nstepScale = option(default=0.5,type=range,min=0,max=2,step=0.01)\nstepValue = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=0.25,type=range,min=0,max=10,step=0.01,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\nsrc = option(default=\"high/low\",type=list,options=[\"open\", \"high\", \"low\", \"close\",\"hl2\",\"ohl3\",\"ohlc4\",\"hlcc4\",\"high/low\",\"low/high\"])\ncolor0 = option(default=rgba(0,0,0,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=20,type=range,min=1,max=200, step=1)\natrLength = option(default=20,type=range,min=1,max=200, step=1)\nuseHK = option(default=true,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=true,type=checkbox)\nstrokeWidth = option(default=0,type=number,description=\"For debug purpose\")\n\nif (!liquidityAtPrices) {\n  // init\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  resistances = []\n  supports = []\n  pendingRedraws = []\n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // bind boundaries reference\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\n\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\npriceRef = price\n\n// grid size\nif (stepValue) {\n  // absolute\n  steps = stepValue\n} else {\n  // calculated with atr\n  var hl = price.high - price.low\n  var hc = Math.abs(price.high - priceRef[1].close)\n  var lc = Math.abs(price.low - priceRef[1].close)\n  var atr = sma(Math.max(hl, hc, lc), atrLength)\n\n  if (bar.length < atrLength) {\n    return\n  }\n\n  if (!steps) {\n    steps = atr * stepScale\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\nvol = buyVolume + sellVolume\n\noi = $openinterest\nvar oiDelta = oi.high - oi.low\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\n\n// custom src\nvar resolvedSrc  = priceRef[1][options.src]\nif (resolvedSrc === undefined) {\n  if (options.src === 'hl2') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low) / 2\n  } else if (options.src === 'ohl3') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low) / 3\n  } else if (options.src === 'ohlc4') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (options.src === 'hlcc4') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low + priceRef[1].close + priceRef[1].close) / 4\n  }\n}\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  if (options.src === 'high/low') {\n    resolvedSrc = lev > 0 ? priceRef[1].high : priceRef[1].low\n  } else if (options.src === 'low/high') {\n    resolvedSrc = lev > 0 ? priceRef[1].low : priceRef[1].high\n  }\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  var lp = (resolvedSrc + resolvedSrc * (100 / lev / 100))\n  \n  // rounded lp median (the cell id)\n  var slp = Math.ceil(lp / steps) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      count: 0,\n      top: top,\n      bottom: bottom\n    }\n    \n    if (lev > 0) {\n        resistances.push(slp)\n        resistances.sort((a, b) => a - b)\n    } else {\n        supports.push(slp)\n        supports.sort((a, b) => b - a)\n    }\n  }\n  \n  // update cell\n  liquidityAtPrices[slp].count++\n  liquidityAtPrices[slp].strength += lev > 0 ? sellRatio : buyRatio\n  \n  var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  if (ratio < 0.001 || oiDelta < 10) {\n    continue\n  }\n  \n  liquidityAtPrices[slp].color = interpolate(ratio, color0, color1, color2, color3)\n\n  if (liquidityAtPrices[slp].strength > options.threshold) {\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.push(slp)\n    }\n  }\n}\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length\n      }\n      \n      cell.id = Math.random().toString()\n      renderer.indicators[indicatorId].series[usedIndex] ={\n        id: cell.id,\n        time: time,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: cell.color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  if (\n   price.low <= supports[i] || liquidityAtPrices[supports[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[supports[i]].id] = bar.length\n    delete liquidityAtPrices[supports[i]]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[supports[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  if (\n   price.high >= resistances[i] || liquidityAtPrices[resistances[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[resistances[i]].id] = bar.length\n    delete liquidityAtPrices[resistances[i]]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[resistances[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define available series\nif (renderer.indicators[indicatorId].series[0]) {\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[1]) {\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[2]) {\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[3]) {\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[4]) {\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[5]) {\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[6]) {\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[7]) {\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[8]) {\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[9]) {\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[10]) {\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[11]) {\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[12]) {\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[13]) {\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[14]) {\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[15]) {\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[16]) {\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}",
                "createdAt": 1713246424998,
                "updatedAt": 1713335066518,
                "options": {
                  "priceScaleId": "right",
                  "leverages": "5|20|100",
                  "threshold": 0,
                  "fadeOut": 0,
                  "stepScale": 0.5,
                  "stepValue": "",
                  "strength": 0.25,
                  "quote": 0,
                  "exchange": 0,
                  "type": "perp",
                  "src": "high/low",
                  "volLength": 20,
                  "atrLength": 20,
                  "useHK": true,
                  "useLog": true,
                  "strokeWidth": 0,
                  "visible": false,
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  }
                },
                "optionsDefinitions": {
                  "leverages": {
                    "default": "5|20|100",
                    "type": "text"
                  },
                  "threshold": {
                    "default": 0,
                    "type": "range",
                    "min": 0,
                    "max": 220,
                    "log": true
                  },
                  "fadeOut": {
                    "default": 0,
                    "type": "range",
                    "min": 0,
                    "max": 1,
                    "log": true,
                    "step": 0.001
                  },
                  "stepScale": {
                    "default": 0.5,
                    "type": "range",
                    "min": 0,
                    "max": 2,
                    "step": 0.01
                  },
                  "stepValue": {
                    "default": "",
                    "type": "text",
                    "placeholder": "empty = ATR"
                  },
                  "strength": {
                    "default": 0.25,
                    "type": "range",
                    "min": 0,
                    "max": 10,
                    "step": 0.01,
                    "log": true
                  },
                  "quote": {
                    "default": 0,
                    "type": "list",
                    "options": [
                      null,
                      "USD",
                      "USDT",
                      "TUSD",
                      "USDC"
                    ],
                    "rebuild": true
                  },
                  "exchange": {
                    "default": 0,
                    "type": "exchange",
                    "rebuild": true
                  },
                  "type": {
                    "default": "perp",
                    "type": "list",
                    "options": [
                      null,
                      "spot",
                      "perp"
                    ],
                    "rebuild": true
                  },
                  "src": {
                    "default": "high/low",
                    "type": "list",
                    "options": [
                      "open",
                      "high",
                      "low",
                      "close",
                      "hl2",
                      "ohl3",
                      "ohlc4",
                      "hlcc4",
                      "high/low",
                      "low/high"
                    ]
                  },
                  "color0": {
                    "default": "rgba(0,0,0,0)",
                    "type": "color"
                  },
                  "color1": {
                    "default": "rgb(63,16,87)",
                    "type": "color"
                  },
                  "color2": {
                    "default": "rgb(76,152,134)",
                    "type": "color"
                  },
                  "color3": {
                    "default": "rgb(240,218,24)",
                    "type": "color"
                  },
                  "volLength": {
                    "default": 20,
                    "type": "range",
                    "min": 1,
                    "max": 200,
                    "step": 1
                  },
                  "atrLength": {
                    "default": 20,
                    "type": "range",
                    "min": 1,
                    "max": 200,
                    "step": 1
                  },
                  "useHK": {
                    "default": true,
                    "type": "checkbox",
                    "description": "Use heikinashi as source"
                  },
                  "useLog": {
                    "default": true,
                    "type": "checkbox"
                  },
                  "strokeWidth": {
                    "default": 0,
                    "type": "number",
                    "description": "For debug purpose"
                  }
                },
                "series": [
                  "liquidation-heatmap-copy-1",
                  "usmsj0tb",
                  "mm2cwteo",
                  "iqdmh2y8",
                  "ujtk9a6u",
                  "6d1d3q89",
                  "uwtcq6kx",
                  "2q3vh5f9",
                  "41wtgrk7",
                  "60ze2mrz",
                  "9uxulfj9",
                  "79s3mpsu",
                  "enry53at",
                  "egibxd8t",
                  "ae75rtt4",
                  "shkgxufi",
                  "o1uw9spn"
                ],
                "displayName": "Liquidation Heatmap copy 1",
                "unsavedChanges": false
              },
              "_tl0sezw2my46cdj3": {
                "id": "_tl0sezw2my46cdj3",
                "libraryId": "top-bands-spots-copy-1",
                "name": "Top Levels Spot/Perp",
                "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\nminVolume = option(default=50,type=range,min=0,max=1000)\r\nmaxVolume = option(default=500,type=range,min=0,max=5000)\r\ndynamicMax = option(default=true,type=checkbox)\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    topBandAtPrice = {}\r\n\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n\r\n    colorLevel0 = options.colorLevel0 \r\n    colorLevel1 = options.colorLevel1\r\n    colorLevel = options.colorLevel\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push({\r\n        index: i,\r\n        redrawAt: 0 \r\n      })\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\n/*if (bar.length < lastIndex) {\r\n  return\r\n}*/\r\n\r\n\r\n\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\n  if( new Date().getTime() > (renderer.timestamp + renderer.timeframe)*1000 ){\r\n    return\r\n  } \r\n\r\nif( dynamicMax ){\r\n  levels.bids.sort( (a, b) => a[0] - b[0] )\r\n  levels.asks.sort( (a, b) => a[0] - b[0] )\r\n  maxVolumeDetected = levels.bids[0][1] > levels.asks[0][1] ? levels.bids[0][1] : levels.asks[0][1];\r\n}\r\n\r\nlevels.bids.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n\r\n\r\n  if( level[1] < minVolume ){\r\n    return;\r\n  }\r\n\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] /(dynamicMax ? maxVolumeDetected : maxVolume), colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nlevels.asks.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nif (pendingRedraws.length) {\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\r\n\r\n    if (slot) {\r\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\r\n      usedSlots.push(usedIndex)\r\n\r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time + renderer.timeframe * 10,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n      slotsToRelease.push(usedIndex)\r\n    }\r\n\r\n    delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      redrawAt: bar.length + 1\r\n    })\r\n  }\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
                "createdAt": 1713304521424,
                "updatedAt": 1713313893105,
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": false,
                  "colorLevels": "rgb(255,255,255)",
                  "colorLevel1": "rgba(255,235,59,0.73)",
                  "colorLevel0": "rgba(156,39,176,0.73)",
                  "colorLevel": "rgba(120,123,134,0.83)",
                  "level0": 700,
                  "level1": 400,
                  "maxVolume": 400,
                  "minVolume": 0,
                  "startOpacity": 0.4,
                  "togglePerp": false,
                  "bandSize": 20,
                  "lastValueVisible": false,
                  "color": "rgb(76,175,80)",
                  "limitPercent": 6,
                  "priceLineVisible": false,
                  "strokeWidth": 0,
                  "strokeColor": "rgb(49,121,245)",
                  "dynamicMax": false
                },
                "optionsDefinitions": {
                  "strokeWidth": {
                    "default": 0,
                    "type": "number",
                    "description": "For debug purpose"
                  },
                  "minVolume": {
                    "default": 50,
                    "type": "range",
                    "min": 0,
                    "max": 1000
                  },
                  "maxVolume": {
                    "default": 500,
                    "type": "range",
                    "min": 0,
                    "max": 5000
                  },
                  "dynamicMax": {
                    "default": true,
                    "type": "checkbox"
                  }
                },
                "displayName": "Top Levels Spot/Perp",
                "series": [
                  "top-bands-spots-copy-1",
                  "uhx1york",
                  "txultkkx",
                  "6ro226y1",
                  "vbz7bhu6",
                  "oeh5gyvk",
                  "38m9y9ay",
                  "0ns84qv3",
                  "u3kkacin",
                  "nm8lritr",
                  "a4te21dl",
                  "4venzcro",
                  "4an02ovu",
                  "p07n1z41",
                  "10l9e9sk",
                  "m3vbc2lz",
                  "zhd9vcil"
                ],
                "unsavedChanges": false
              },
              "_0mg4vqeobgu9ep1h": {
                "id": "_0mg4vqeobgu9ep1h",
                "name": "Top Bands Spots copy 2",
                "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    topBandAtPrice = {}\r\n\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0 \r\n    colorLevel1 = options.colorLevel1\r\n    colorLevel = options.colorLevel\r\n\r\n    /*colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()*/\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push({\r\n        index: i,\r\n        redrawAt: 0 \r\n      })\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\nif (bar.length < lastIndex) {\r\n  return\r\n}\r\n\r\nif( new Date().getTime() > (renderer.timestamp + renderer.timeframe)*1000 ){\r\n  return\r\n} \r\n\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\n//levels.bids.sort( (a, b) => a[0] - b[0] )\r\n//levels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nlevels.bids.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nlevels.asks.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nif (pendingRedraws.length) {\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\r\n\r\n    if (slot) {\r\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\r\n      usedSlots.push(usedIndex)\r\n\r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n      slotsToRelease.push(usedIndex)\r\n    }\r\n\r\n    delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      redrawAt: bar.length + 1\r\n    })\r\n  }\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": false,
                  "colorLevels": "rgb(255,255,255)",
                  "colorLevel1": "rgba(255,255,255,0.94)",
                  "colorLevel0": "rgba(156,39,176,0.93)",
                  "colorLevel": "rgba(120,123,134,0.83)",
                  "level0": 700,
                  "level1": 400,
                  "maxVolume": 500,
                  "minVolume": 200,
                  "startOpacity": 0.4,
                  "togglePerp": false,
                  "bandSize": 20,
                  "lastValueVisible": false,
                  "color": "rgb(76,175,80)",
                  "limitPercent": 6,
                  "priceLineVisible": false,
                  "strokeWidth": 0,
                  "strokeColor": "rgb(49,121,245)"
                },
                "optionsDefinitions": {
                  "strokeWidth": {
                    "default": 0,
                    "type": "number",
                    "description": "For debug purpose"
                  }
                },
                "series": [
                  "_0mg4vqeobgu9ep1h",
                  "xwv4tq6h",
                  "stbqohm4",
                  "zq49egdi",
                  "g1w5m32q",
                  "qydwmlsr",
                  "p0u18sg5",
                  "obgt2dxr",
                  "emc3i1h8",
                  "fx3tf9q3",
                  "7gpzmvof",
                  "sdhngb4m",
                  "d8iubakv",
                  "vtqolvft",
                  "g5ljd6if",
                  "yh6qun35",
                  "wpovysd8"
                ],
                "displayName": "Top Bands Spots copy 2"
              },
              "_cj0l7ltnxfoj1neg": {
                "id": "_cj0l7ltnxfoj1neg",
                "libraryId": "top-levels",
                "name": "Top Levels ",
                "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\nminVolumeSpot = option(default=50,type=range,min=0,max=1000)\r\nmaxVolumeSpot = option(default=500,type=range,min=0,max=5000)\r\nminVolumePerp = option(default=50,type=range,min=0,max=1000)\r\nmaxVolumePerp = option(default=500,type=range,min=0,max=5000)\r\ndynamicMax = option(default=true,type=checkbox)\r\nuseSameColor = option(default=true,type=checkbox)\r\napplyAlpha = option(default=false,type=checkbox)\r\nuseSingleColor = option(default=false,type=checkbox)\r\neth = option(default=false,type=checkbox)\r\nalphaBase = option(default=0.2,type=range,min=0,max=1,step=0.1)\r\ncolor0 = option(default=rgba(0,0,0,0),type=color)\r\ncolor1 = option(default=rgb(63,16,87),type=color)\r\ncolor2 = option(default=rgb(76,152,134),type=color)\r\ncolor3 = option(default=rgb(240,218,24),type=color)\r\n\r\ncolorPerp0 = option(default=rgba(0,0,0,0),type=color)\r\ncolorPerp1 = option(default=rgb(63,16,87),type=color)\r\ncolorPerp2 = option(default=rgb(76,152,134),type=color)\r\ncolorPerp3 = option(default=rgb(240,218,24),type=color)\r\ncolorBoth = option(default=rgb(240,218,24),type=color)\r\nstrengthSpot = option(default=1,type=range,min=0,max=1,step=0.01)\r\nstrengthPerp = option(default=1,type=range,min=0,max=1,step=0.01)\r\n\r\nfunction interpolateAlpha(ratio, c ){\r\n  var startOpacity = alphaBase\r\n  var alpha = startOpacity + (1 - startOpacity) * ratio\r\n  var alphaRounded = Math.round(alpha * 100) / 100 \r\n  var colorBase = c.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n  var alpha = colorBase.pop()\r\n  var finalColor = 'rgba(' + colorBase.join(',') + ',' + alphaRounded + ')'\r\n  return finalColor\r\n}\r\n/*if( useSameColor ){  \r\n  colorPerp0 = color0\r\n  colorPerp1 = color1\r\n  colorPerp2 = color2\r\n  colorPerp3 = color3\r\n}*/\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    \r\n    // runs only once\r\n    pendingMarkers = [] \r\n    \r\n    bandSize = options.bandSize || 15\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push(i)\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// Don't presist\r\nvar topBandAtPrice = {};\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\nif (bar.length < lastIndex) {\r\n  //console.log('not last index')\r\n  return\r\n}\r\n\r\n// avoid too many changes\r\nif( new Date().getTime() >= (renderer.timestamp + renderer.timeframe)*1000 ){\r\n  /*for (var i = 0; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n     renderer.indicators[indicatorId].series[i] ={\r\n        id: Math.random().toString(),\r\n        time: renderer.timestamp,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n  }*/\r\n  //console.log('not last candle', renderer.timestamp)\r\n  return\r\n} \r\n\r\n/*function getRandomNumber() {\r\n  return Math.floor(Math.random() * (4000 - 500 + 1)) + 500;\r\n}*/\r\n//var perpLevels = {bids: [[$price.close - getRandomNumber(), 5000]], asks: [[$price.close + getRandomNumber(), 5000]]}\r\n//var spotLevels = {bids: [[$price.close - getRandomNumber(), 1000]], asks: [[$price.close + getRandomNumber(), 5000]]}\r\n\r\nvar perpLevels = eth ? ORDERBOOK:AGGRPERP-ETHUSD.zlevels  : ORDERBOOK:AGGRPERP-BTCUSD.zlevels \r\nvar spotLevels = eth ? ORDERBOOK:AGGRPERP-ETHUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\n\r\nif( !perpLevels && !spotLevels ){\r\n  return\r\n}\r\n\r\n/*if( dynamicMax ){\r\n  levels.bids.sort( (a, b) => a[0] - b[0] )\r\n  levels.asks.sort( (a, b) => a[0] - b[0] )\r\n  maxVolumeDetected = levels.bids[0][1] > levels.asks[0][1] ? levels.bids[0][1] : levels.asks[0][1];\r\n}*/\r\n\r\n// 1.5 seconds before end of candle\r\nvar isAboutToEnd = new Date().getTime() >= (renderer.timestamp + renderer.timeframe)*1000 - 1800\r\n\r\nif( !isAboutToEnd ){\r\n  spotLevels.bids.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumeSpot ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumeSpot)\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio * strengthSpot)\r\n\r\n    if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = color3\r\n    }else{ \r\n      topBandAtPrice[resolvedSrc].color =  interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color =  interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color);\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  spotLevels.asks.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumeSpot ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumeSpot)\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthSpot)\r\n\r\n    if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = color3\r\n    }else{ \r\n      topBandAtPrice[resolvedSrc].color =  interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color =  interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color);\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  perpLevels.bids.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumePerp ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumePerp)\r\n    var hasSpotLevel = topBandAtPrice[resolvedSrc].strength > 0.3\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthPerp)\r\n\r\n    if( hasSpotLevel ){\r\n      topBandAtPrice[resolvedSrc].color = colorBoth\r\n    } else if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = colorPerp3\r\n    } else if( useSameColor ){\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }else{\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, colorPerp0, colorPerp1, colorPerp2, colorPerp3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color = interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color );\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  perpLevels.asks.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumePerp ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumePerp)\r\n    var hasSpotLevel = topBandAtPrice[resolvedSrc].strength > 0.3\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthPerp)\r\n\r\n    if( hasSpotLevel ){\r\n      topBandAtPrice[resolvedSrc].color = colorBoth\r\n    } else if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = colorPerp3\r\n    } else if( useSameColor ){\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }else{\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, colorPerp0, colorPerp1, colorPerp2, colorPerp3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color = interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color );\r\n    }\r\n    \r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n}else{\r\n  console.log('Anout to expire')\r\n  for (var i = 0; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n     renderer.indicators[indicatorId].series[i] ={\r\n        id: Math.random().toString(),\r\n        time: time + renderer.timeframe,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n  }\r\n}\r\n\r\nif (pendingRedraws.length) {\r\n  \r\n  // free all the slots that won't be redrawn\r\n  for (var i = 0; i < usedSlots.length; i++) {\r\n\r\n    var level = usedSlots[i][1]\r\n\r\n    // do we have a level to redraw?\r\n    var exist = pendingRedraws.includes(level)\r\n    if( !exist ){\r\n      var usedIndex = usedSlots[i][0]\r\n\r\n      freeSlots.push(usedIndex)\r\n      usedSlots.splice(i--, 1)\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: Math.random().toString(),\r\n        time: time + renderer.timeframe,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    // find a brokenarea index to use\r\n    // var slot = freeSlots.find(slot => slot.redrawAt <= bar.length)\r\n    // find a brokenarea already use to draw same level or first one\r\n    var reuse = usedSlots.find(slot => slot[1] === pendingRedraws[i])\r\n    \r\n    var useIndex = (reuse && reuse[0]) || (freeSlots.length && freeSlots[0]) \r\n\r\n    // if we have one\r\n    if (useIndex >= 0) {\r\n      // removed it from freeSlots\r\n      freeSlots.splice(freeSlots.indexOf(useIndex), 1)\r\n      // put it in usedSlots\r\n      !reuse && usedSlots.push([useIndex, pendingRedraws[i]])\r\n      \r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      /*renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time - renderer.timeframe,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.top,\r\n        extendRight: false,\r\n        color: cell.color\r\n      }*/\r\n      renderer.indicators[indicatorId].series[useIndex] ={\r\n        id: cell.id,\r\n        time: time + renderer.timeframe,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n\r\n      //slotsToRelease.push([usedIndex, pendingRedraws[i]])\r\n    }else{\r\n      console.log('No more slots')\r\n    }\r\n\r\n    //delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  /*for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var ind = slotsToRelease[i][0]\r\n    var level = slotsToRelease[i][1]\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(ind), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      level: level\r\n    })\r\n  }*/\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[17]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[17] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[18]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[18] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[19]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[19] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
                "createdAt": 1713314961958,
                "updatedAt": 1713486743951,
                "options": {
                  "priceScaleId": "right",
                  "scaleMargins": {
                    "top": 0.33,
                    "bottom": 0.44
                  },
                  "visible": true,
                  "colorLevels": "rgb(255,255,255)",
                  "colorLevel1": "rgba(255,235,59,0.73)",
                  "colorLevel0": "rgba(156,39,176,0.73)",
                  "colorLevel": "rgba(120,123,134,0.83)",
                  "level0": 700,
                  "level1": 400,
                  "maxVolume": 400,
                  "minVolume": 0,
                  "startOpacity": 0.4,
                  "togglePerp": false,
                  "bandSize": 40,
                  "lastValueVisible": false,
                  "color": "rgb(76,175,80)",
                  "limitPercent": 6,
                  "priceLineVisible": false,
                  "strokeWidth": 0,
                  "strokeColor": "rgb(49,121,245)",
                  "dynamicMax": false,
                  "minVolumeSpot": 100,
                  "maxVolumeSpot": 500,
                  "minVolumePerp": 200,
                  "maxVolumePerp": 1500,
                  "eth": false,
                  "color1": "rgba(255,255,255,0.55)",
                  "strengthSpot": 1,
                  "strengthPerp": 1,
                  "useSameColor": false,
                  "colorPerp0": "rgba(42,46,57,0.08)",
                  "colorPerp1": "rgba(255,255,255,0.55)",
                  "colorPerp2": "rgb(255,152,0)",
                  "colorPerp3": "rgb(41,98,255)",
                  "colorBoth": "rgb(178,40,51)",
                  "color2": "rgb(56,142,60)",
                  "color3": "rgb(255,235,59)",
                  "useAlpha": true,
                  "applyAlpha": true,
                  "useSingleColor": true,
                  "alphaBase": 0.1,
                  "color0": "rgba(42,46,57,0.08)"
                },
                "optionsDefinitions": {
                  "strokeWidth": {
                    "default": 0,
                    "type": "number",
                    "description": "For debug purpose"
                  },
                  "minVolumeSpot": {
                    "default": 50,
                    "type": "range",
                    "min": 0,
                    "max": 1000
                  },
                  "maxVolumeSpot": {
                    "default": 500,
                    "type": "range",
                    "min": 0,
                    "max": 5000
                  },
                  "minVolumePerp": {
                    "default": 50,
                    "type": "range",
                    "min": 0,
                    "max": 1000
                  },
                  "maxVolumePerp": {
                    "default": 500,
                    "type": "range",
                    "min": 0,
                    "max": 5000
                  },
                  "dynamicMax": {
                    "default": true,
                    "type": "checkbox"
                  },
                  "useSameColor": {
                    "default": true,
                    "type": "checkbox"
                  },
                  "applyAlpha": {
                    "default": 0,
                    "type": "checkbox"
                  },
                  "useSingleColor": {
                    "default": 0,
                    "type": "checkbox"
                  },
                  "eth": {
                    "default": 0,
                    "type": "checkbox"
                  },
                  "alphaBase": {
                    "default": 0.2,
                    "type": "range",
                    "min": 0,
                    "max": 1,
                    "step": 0.1
                  },
                  "color0": {
                    "default": "rgba(0,0,0,0)",
                    "type": "color"
                  },
                  "color1": {
                    "default": "rgb(63,16,87)",
                    "type": "color"
                  },
                  "color2": {
                    "default": "rgb(76,152,134)",
                    "type": "color"
                  },
                  "color3": {
                    "default": "rgb(240,218,24)",
                    "type": "color"
                  },
                  "colorPerp0": {
                    "default": "rgba(0,0,0,0)",
                    "type": "color"
                  },
                  "colorPerp1": {
                    "default": "rgb(63,16,87)",
                    "type": "color"
                  },
                  "colorPerp2": {
                    "default": "rgb(76,152,134)",
                    "type": "color"
                  },
                  "colorPerp3": {
                    "default": "rgb(240,218,24)",
                    "type": "color"
                  },
                  "colorBoth": {
                    "default": "rgb(240,218,24)",
                    "type": "color"
                  },
                  "strengthSpot": {
                    "default": 1,
                    "type": "range",
                    "min": 0,
                    "max": 1,
                    "step": 0.01
                  },
                  "strengthPerp": {
                    "default": 1,
                    "type": "range",
                    "min": 0,
                    "max": 1,
                    "step": 0.01
                  }
                },
                "displayName": "Top Levels ",
                "series": [
                  "top-levels",
                  "ap1ve3s1",
                  "2vweth3k",
                  "gc1f2uix",
                  "eolz29it",
                  "lst0cwp7",
                  "rz8z43yz",
                  "cupo8x2n",
                  "6se81xup",
                  "k2zdw8hi",
                  "064iqart",
                  "xunwzms9",
                  "k4bt4xfa",
                  "ssqkdecd",
                  "6thw7255",
                  "7bzwowsk",
                  "uxu9bnsc",
                  "wwg1dca7",
                  "okxn8edw",
                  "p8tmu931"
                ],
                "unsavedChanges": false
              }
            },
            "indicatorOrder": [
              "price",
              "_cj0l7ltnxfoj1neg",
              "_7o282jzm9vulptiq",
              "overlays-all",
              "orderbook-0-1-spot",
              "liquidations",
              "orderbook-0-1-perp",
              "perpvscoinbase",
              "orderbook-perp",
              "large-liquidations",
              "spotvsperp",
              "orderbook-spot",
              "trades",
              "ob-speed",
              "averages",
              "_bc6lfhgxb0wc36l9",
              "bollinger-bands",
              "_f8i6stuml3q7zwkc",
              "_pngsl31b0gpvtuas",
              "top-bands-perps",
              "top-bands-spots",
              "alerts",
              "_oh4jdeuqr3sfb21e",
              "volume",
              "_my4zvk49em6mh062",
              "_6fov3tmuy13lvmmv",
              "_0mg4vqeobgu9ep1h",
              "_tl0sezw2my46cdj3"
            ],
            "priceScales": {
              "right": {
                "scaleMargins": {
                  "top": 0.33,
                  "bottom": 0.44
                },
                "indicators": [
                  "Price"
                ],
                "priceFormat": {
                  "precision": 1,
                  "minMove": 0.1
                }
              },
              "cvd": {
                "scaleMargins": {
                  "top": 0.39,
                  "bottom": 0.48
                },
                "indicators": [
                  "CVD"
                ]
              },
              "volume_liquidations": {
                "scaleMargins": {
                  "top": 0,
                  "bottom": 0.96
                },
                "indicators": [
                  "Liquidations"
                ]
              },
              "volume": {
                "scaleMargins": {
                  "top": 0.62,
                  "bottom": 0.3
                },
                "indicators": [
                  "Volume"
                ]
              },
              "orderbook-0-1-spot": {
                "scaleMargins": {
                  "top": 0.71,
                  "bottom": 0.25
                },
                "indicators": [
                  "Orderbook 0-1% spot"
                ],
                "priceFormat": {
                  "precision": 1,
                  "minMove": 0.1
                }
              },
              "orderbook-0-1-perp": {
                "scaleMargins": {
                  "top": 0.86,
                  "bottom": 0.1
                },
                "indicators": [
                  "Orderbook 0-1% perp"
                ],
                "priceFormat": {
                  "precision": 1,
                  "minMove": 0.1
                }
              },
              "orderbook-spot": {
                "scaleMargins": {
                  "top": 0.77,
                  "bottom": 0.15
                },
                "indicators": [
                  "Orderbook spot"
                ],
                "priceFormat": {
                  "precision": 1,
                  "minMove": 0.1
                }
              },
              "orderbook-perp": {
                "scaleMargins": {
                  "top": 0.91,
                  "bottom": 0
                },
                "indicators": [
                  "Orderbook Perp"
                ]
              },
              "left": {
                "scaleMargins": {
                  "top": 0.59,
                  "bottom": 0.28
                }
              },
              "test": {
                "scaleMargins": {
                  "top": 0.1,
                  "bottom": 0.2
                }
              },
              "bids-asks-total": {
                "scaleMargins": {
                  "top": 0.09,
                  "bottom": 0.82
                },
                "indicators": [
                  "bids asks total"
                ]
              },
              "cvd-btc-spot-cb": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD Coinbase"
                ]
              },
              "cvd-binance-perp-futures": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD Binance Perps"
                ]
              },
              "cvd-binance-spot": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD Binance Spot "
                ]
              },
              "perps-premiuum-simple": {
                "scaleMargins": {
                  "top": 0.2,
                  "bottom": 0.77
                },
                "indicators": [
                  "perps premiuum simple"
                ]
              },
              "perpvscoinbase": {
                "scaleMargins": {
                  "top": 0.23,
                  "bottom": 0.74
                },
                "indicators": [
                  "perpvscoinbase"
                ]
              },
              "spotvsperp": {
                "scaleMargins": {
                  "top": 0.2,
                  "bottom": 0.77
                },
                "indicators": [
                  "SpotVSPerp"
                ]
              },
              "trades": {
                "scaleMargins": {
                  "top": 0.67,
                  "bottom": 0.29
                },
                "indicators": [
                  "trades"
                ]
              },
              "obv": {
                "scaleMargins": {
                  "top": 0.14,
                  "bottom": 0.21
                }
              },
              "obv-copy-1": {
                "scaleMargins": {
                  "top": 0.14,
                  "bottom": 0.21
                }
              },
              "ob-speed": {
                "scaleMargins": {
                  "top": 0.62,
                  "bottom": 0.33
                },
                "indicators": [
                  "OB speed"
                ]
              },
              "cvdperp": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD (BTC PERP)"
                ]
              },
              "cvdspot": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD (BTC SPOT)"
                ]
              },
              "_v9ix9ggm0looumtf": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD Binance"
                ]
              },
              "_ilwzivhp75r7wuat": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.69
                }
              },
              "_bc6lfhgxb0wc36l9": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                },
                "indicators": [
                  "CVD Binance P"
                ]
              },
              "_f8i6stuml3q7zwkc": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                }
              },
              "_pngsl31b0gpvtuas": {
                "scaleMargins": {
                  "top": 0.04,
                  "bottom": 0.8
                }
              },
              "_tdqicpndr092c1gk": {
                "scaleMargins": {
                  "top": 0.21,
                  "bottom": 0.69
                },
                "indicators": [
                  "OI"
                ]
              }
            },
            "layouting": false,
            "showIndicators": true,
            "timeframe": "60",
            "refreshRate": 1000,
            "showAlerts": true,
            "showAlertsLabel": true,
            "showLegend": false,
            "fillGapsWithEmpty": true,
            "showHorizontalGridlines": false,
            "horizontalGridlinesColor": "rgba(255,255,255,.1)",
            "showVerticalGridlines": false,
            "verticalGridlinesColor": "rgba(255,255,255,.1)",
            "showWatermark": false,
            "watermarkColor": "rgba(255,255,255,.1)",
            "showBorder": true,
            "borderColor": null,
            "showLeftScale": false,
            "showRightScale": true,
            "showTimeScale": true,
            "hiddenMarkets": {},
            "barSpacing": 0.5801204906573709,
            "navigationState": {
              "tab": "script",
              "optionsQuery": "",
              "fontSizePx": 14
            }
          },
          "markets": [
            "BINANCE_FUTURES:btcusd_perp",
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCUSDT",
            "OKEX:BTC-USD-SWAP",
            "ORDERBOOK:AGGROI-BTCUSD"
          ]
        }
      },
      "layout": [
        {
          "i": "chart",
          "type": "chart",
          "x": 0,
          "y": 0,
          "w": 24,
          "h": 24,
          "moved": false
        }
      ]
    },
    "chart": {
      "indicatorsErrors": {
        "_7o282jzm9vulptiq": "Cannot read properties of undefined (reading '0')"
      },
      "indicators": {
        "liquidations": {
          "enabled": true,
          "name": "Liquidations",
          "description": "Liquidations by side",
          "script": "plothistogram(lbuy, color=options.upColor)\nplothistogram(-lsell, color=options.downColor)",
          "options": {
            "priceFormat": {
              "type": "volume"
            },
            "priceScaleId": "volume_liquidations",
            "upColor": "rgb(255,76,243)",
            "downColor": "rgb(255,183,77)",
            "scaleMargins": {
              "top": 0,
              "bottom": 0.96
            },
            "visible": true,
            "lastValueVisible": true,
            "priceLineVisible": false,
            "baseLineVisible": false
          },
          "id": "liquidations",
          "createdAt": 1700269685372,
          "updatedAt": null,
          "series": [
            "liquidations",
            "ec52ojdp"
          ],
          "unsavedChanges": true,
          "optionsDefinitions": {}
        },
        "price": {
          "enabled": true,
          "name": "Price",
          "script": "src = { sources: { \"BINANCE_FUTURES:btcusdt\":BINANCE_FUTURES:btcusdt }, localTimestamp: time }\r\n\r\nvar ohlc = options.useHeikinAshi ? avg_heikinashi(src) : options.useGaps ? avg_ohlc_with_gaps(src) : avg_ohlc(src)\r\n\r\nplotcandlestick(ohlc, id=price)",
          "options": {
            "priceScaleId": "right",
            "priceFormat": {
              "auto": true,
              "precision": 1,
              "minMove": 0.1
            },
            "priceLineVisible": true,
            "lastValueVisible": true,
            "borderVisible": true,
            "upColor": "rgb(59,202,109)",
            "downColor": "rgb(214,40,40)",
            "borderUpColor": "rgb(59,202,109)",
            "borderDownColor": "rgb(239,67,82)",
            "wickUpColor": "rgb(209,212,220)",
            "wickDownColor": "rgb(239,67,82)",
            "useGaps": false,
            "useHeikinAshi": false,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": true
          },
          "id": "price",
          "createdAt": 1700269685372,
          "updatedAt": 1700590671954,
          "series": [
            "price"
          ],
          "unsavedChanges": true,
          "preview": {},
          "optionsDefinitions": {}
        },
        "orderbook-0-1-spot": {
          "script": "if(!upper){\r\n  upper = options.upper || 39\r\n  lower = options.lower || -39\r\n}\r\nvar levels = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\nvar ratioValue = levels && levels[0]\r\n\r\nplothistogram({\r\n    time: time,\r\n    value: ratioValue,\r\n    color: ratioValue < lower ? options.warnColor : ratioValue > upper ? options.warnColor : options.ratioColor\r\n}, title=\"spot\")\r\n\r\n\r\nif( upperLine === 0 ){  \r\n   upperLine = series[0].createPriceLine({ \r\n      price: upper, \r\n      index: bar.length,\r\n      color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }\r\n\r\n  if( lowerLine === 0 ){  \r\n   lowerLine = series[0].createPriceLine({ \r\n      price: lower, \r\n      index: bar.length,\r\n      color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }",
          "name": "Orderbook 0-1% spot",
          "priceScaleId": "orderbook-0-1",
          "id": "orderbook-0-1-spot",
          "options": {
            "priceScaleId": "orderbook-0-1-spot",
            "scaleMargins": {
              "top": 0.71,
              "bottom": 0.25
            },
            "useGaps": true,
            "useHeikinAshi": null,
            "priceFormat": {
              "type": "percent",
              "precision": 1,
              "minMove": 0.1,
              "auto": true
            },
            "visible": false,
            "lastValueVisible": true,
            "baseLineVisible": true,
            "pivotLength": 14,
            "upper": null,
            "lowerColor": "rgb(120,123,134)",
            "upperColor": "rgb(120,123,134)",
            "lower": null,
            "ratioColor": "rgb(149,152,161)",
            "warnColor": "rgb(255,235,59)"
          },
          "series": [
            "orderbook-0-1-spot"
          ],
          "displayName": "Orderbook 0-1% spot",
          "unsavedChanges": true,
          "preview": {},
          "createdAt": 1700590114591,
          "updatedAt": 1700636345055,
          "optionsDefinitions": {}
        },
        "orderbook-0-1-perp": {
          "script": "if(!upper){\r\n  upper = options.upper || 37\r\n  lower = options.lower || -19\r\n}\r\nvar levels = ORDERBOOK:AGGRPERP-BTCUSD.zratios \r\nvar ratioValue = levels && levels[0]\r\n\r\nplothistogram({\r\n    time: time,\r\n    value: ratioValue,\r\n    color: ratioValue <= lower ? options.warnColor : ratioValue >= upper ? options.warnColor : options.ratioColor\r\n}, title=\"perp\")\r\n\r\nif( upperLine === 0 ){  \r\n   upperLine = series[0].createPriceLine({ \r\n      price: upper, \r\n      index: bar.length,\r\n      color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }\r\n\r\n  if( lowerLine === 0 ){  \r\n   lowerLine = series[0].createPriceLine({ \r\n      price: lower, \r\n      index: bar.length,\r\n      color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n  }",
          "name": "Orderbook 0-1% perp",
          "priceScaleId": "orderbook-0-1",
          "id": "orderbook-0-1-perp",
          "options": {
            "priceScaleId": "orderbook-0-1-perp",
            "scaleMargins": {
              "top": 0.86,
              "bottom": 0.1
            },
            "useGaps": true,
            "useHeikinAshi": null,
            "priceFormat": {
              "type": "percent",
              "precision": 1,
              "minMove": 0.1,
              "auto": true
            },
            "visible": false,
            "lastValueVisible": true,
            "baseLineVisible": true,
            "upper": null,
            "lower": null,
            "warnColor": "rgb(24,72,204)",
            "upperColor": "rgb(12,50,153)",
            "lowerColor": "rgb(12,50,153)",
            "ratioColor": "rgb(178,181,190)"
          },
          "series": [
            "orderbook-0-1-perp"
          ],
          "displayName": "Orderbook 0-1% perp",
          "unsavedChanges": true,
          "preview": {},
          "createdAt": 1700598885689,
          "updatedAt": 1700600633815,
          "optionsDefinitions": {}
        },
        "orderbook-spot": {
          "script": "var levels = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\nvar ratio1 = levels && levels[1]\r\nvar ratio2 = levels && levels[2]\r\nvar ratio3 = levels && levels[3]\r\n\r\nif( ratio1Upper === 0 ){\r\n    ratio1Upper = options.upper || 62\r\n    ratio1Lower = options.lower || -62\r\n\r\n    ratio2Upper = options.upper2 || 45\r\n    ratio2Lower = options.lower2 || -45\r\n\r\n    ratio3Upper = options.upper3 || 39\r\n    ratio3Lower = options.lower3 || -39\r\n}\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio3, \r\n    color: ratio3 < ratio3Lower ? options.warnColor : (ratio3 > ratio3Upper ? options.warnColor : options.ratio3Color)\r\n}, title=S3)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio1, \r\n    color: ratio1 < ratio1Lower ? options.warnColor : (ratio1 > ratio1Upper ? options.warnColor : options.ratio1Color)\r\n}, title=S1)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio2, \r\n    color: ratio2 < ratio2Lower ? options.warnColor : (ratio2 > ratio2Upper ? options.warnColor: options.ratio2Color)\r\n}, title=S2)\r\n\r\n/*\r\nline(ratio1Upper, color=options.upperColor)\r\nline(ratio1Lower,color=options.lowerColor)\r\n\r\nline(ratio2Upper, color=options.upper2Color)\r\nline(ratio2Lower,color=options.lower2Color)\r\n*/\r\n\r\nif( upperLine === 0 ){  \r\n    upperLine = series[0].createPriceLine({ \r\n        price: ratio1Upper, \r\n        index: bar.length,\r\n        color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine === 0 ){  \r\n    lowerLine = series[0].createPriceLine({ \r\n        price: ratio1Lower, \r\n        index: bar.length,\r\n        color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( upperLine2 === 0 ){  \r\n    upperLine2 = series[0].createPriceLine({ \r\n        price: ratio2Upper, \r\n        index: bar.length,\r\n        color: options.upper2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine2 === 0 ){  \r\n    lowerLine2 = series[0].createPriceLine({ \r\n        price: ratio2Lower, \r\n        index: bar.length,\r\n        color: options.lower2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nline(0)",
          "name": "Orderbook spot",
          "priceScaleId": "orderbook-spot",
          "id": "orderbook-spot",
          "options": {
            "priceScaleId": "orderbook-spot",
            "scaleMargins": {
              "top": 0.77,
              "bottom": 0.15
            },
            "lastValueVisible": true,
            "priceFormat": {
              "type": "percent",
              "precision": 1,
              "minMove": 0.1,
              "auto": true
            },
            "leverages": null,
            "ratio1": null,
            "ratio2": null,
            "ratio2Color": "rgb(66,189,168)",
            "ratio1Color": "rgb(186,104,200)",
            "visible": false,
            "upper": null,
            "upper2": null,
            "lowerColor": "rgba(74,20,140,0.62)",
            "upperColor": "rgba(171,71,188,0.59)",
            "lower2Color": "rgba(66,189,168,0.63)",
            "upper2Color": "rgba(34,171,148,0.62)",
            "lower": null,
            "lower2": null,
            "warnColor": "rgb(245,124,0)",
            "priceLineVisible": false,
            "baseLineVisible": true,
            "ratio3Color": "rgba(255,255,255,0.69)",
            "upper3": null,
            "lower3": null,
            "lineStyle": 0
          },
          "series": [
            "orderbook-spot",
            "fkorp1iv",
            "dkncdqbn",
            "epqy5hm5",
            "j4wj3mh3",
            "uyyd1vsz",
            "1t6e5l0z",
            "lqsgvcey"
          ],
          "displayName": "Orderbook spot",
          "unsavedChanges": true,
          "preview": {},
          "createdAt": 1700599138239,
          "updatedAt": 1710448059769,
          "optionsDefinitions": {},
          "libraryId": "orderbook-spot"
        },
        "orderbook-perp": {
          "script": "var levels = ORDERBOOK:AGGRPERP-BTCUSD.zratios \r\nvar ratio1 = levels && levels[1]\r\nvar ratio2 = levels && levels[2]\r\nvar ratio3 = levels && levels[3]\r\n\r\nif( ratio1Upper === 0 ){\r\n    ratio1Upper = options.upper || 26\r\n    ratio1Lower = options.lower || -26\r\n\r\n    ratio2Upper = options.upper2 || 35\r\n    ratio2Lower = options.lower2 || -35\r\n\r\n    ratio3Upper = options.upper3 || 39\r\n    ratio3Lower = options.lower3 || -39\r\n}\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio3, \r\n    color: ratio3 < ratio3Lower ? options.warnColor : (ratio3 > ratio3Upper ? options.warnColor : options.ratio3Color)\r\n}, title=P3)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio1, \r\n    color: ratio1 < ratio1Lower ? options.warnColor : (ratio1 > ratio1Upper ? options.warnColor : options.ratio1Color)\r\n}, title=P1)\r\n\r\nplotline({\r\n    time: time,\r\n    value: ratio2, \r\n    color: ratio2 < ratio2Lower ? options.warnColor : (ratio2 > ratio2Upper ? options.warnColor: options.ratio2Color)\r\n}, title=P2)\r\n\r\n/*\r\nline(ratio1Upper, color=options.upperColor)\r\nline(ratio1Lower,color=options.lowerColor)\r\n\r\nline(ratio2Upper, color=options.upper2Color)\r\nline(ratio2Lower,color=options.lower2Color)\r\n*/\r\n\r\nif( upperLine === 0 ){  \r\n    upperLine = series[0].createPriceLine({ \r\n        price: ratio1Upper, \r\n        index: bar.length,\r\n        color: options.upperColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine === 0 ){  \r\n    lowerLine = series[0].createPriceLine({ \r\n        price: ratio1Lower, \r\n        index: bar.length,\r\n        color: options.lowerColor,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( upperLine2 === 0 ){  \r\n    upperLine2 = series[0].createPriceLine({ \r\n        price: ratio2Upper, \r\n        index: bar.length,\r\n        color: options.upper2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\n\r\nif( lowerLine2 === 0 ){  \r\n    lowerLine2 = series[0].createPriceLine({ \r\n        price: ratio2Lower, \r\n        index: bar.length,\r\n        color: options.lower2Color,\r\n        axisLabelVisible: false\r\n    })\r\n}\r\nline(0)",
          "name": "Orderbook Perp",
          "priceScaleId": "orderbook-perp",
          "id": "orderbook-perp",
          "options": {
            "priceScaleId": "orderbook-perp",
            "lower": null,
            "lower2": -32,
            "upper": null,
            "upper2": 32,
            "ratio1Color": "rgb(171,71,188)",
            "lowerColor": "rgba(186,104,200,0.6)",
            "warnColor": "rgb(255,152,0)",
            "upperColor": "rgba(186,104,200,0.62)",
            "ratio2Color": "rgb(76,175,80)",
            "upper2Color": "rgba(76,175,80,0.67)",
            "lower2Color": "rgba(76,175,80,0.66)",
            "visible": false,
            "lastValueVisible": true,
            "scaleMargins": {
              "top": 0.91,
              "bottom": 0
            },
            "ratio3Color": "rgba(255,255,255,0.38)",
            "upper3": null,
            "lower3": null
          },
          "series": [
            "orderbook-perp",
            "i57so2yf",
            "zkcszb3f",
            "hatcvwzy",
            "faqvtplo",
            "myt8ia07",
            "mry8v12u",
            "bddni1us"
          ],
          "displayName": "Orderbook Perp",
          "unsavedChanges": false,
          "optionsDefinitions": {},
          "libraryId": "orderbook-perp",
          "createdAt": 1700696855798,
          "updatedAt": 1710448067929
        },
        "perpvscoinbase": {
          "script": "binance = (BINANCE_FUTURES:btcusdt.high+BINANCE_FUTURES:btcusdt.low+BINANCE_FUTURES:btcusdt.close)/3 \nbybit = (BYBIT:BTCUSDT.high+BYBIT:BTCUSDT.low+BYBIT:BTCUSDT.close)/3 \nokx = (OKEX:BTC-USD-SWAP.high+OKEX:BTC-USD-SWAP.low+OKEX:BTC-USD-SWAP.close)/3 \ncoinbaseSpot = (COINBASE:BTC-USD.high+COINBASE:BTC-USD.low+ COINBASE:BTC-USD.close)/3\n\n\npremium = coinbaseSpot - (binance+bybit+okx)/3\nbaseline = 0\n\n\nplotcloudarea(premium, baseline)\n//line(\n//  ema(premium, 10)\n//)",
          "id": "perpvscoinbase",
          "name": "Coinbase prem.",
          "options": {
            "priceScaleId": "perpvscoinbase",
            "visible": false,
            "priceLineVisible": true,
            "lastValueVisible": true,
            "lowerLineColor": "rgba(119,255,0,0)",
            "positiveColor": "rgb(242,54,69)",
            "negativeColor": "rgb(49,121,245)",
            "higherLineColor": "rgba(255,255,255,0)",
            "priceFormat": {
              "type": "price",
              "minMove": "0.01",
              "precision": 1
            },
            "lineStyle": 1,
            "color": "rgb(209,212,220)",
            "scaleMargins": {
              "top": 0.23,
              "bottom": 0.74
            },
            "baseLineVisible": false
          },
          "description": null,
          "createdAt": 1681264031489,
          "updatedAt": 1705607189308,
          "unsavedChanges": false,
          "series": [
            "perpvscoinbase"
          ],
          "displayName": "Coinbase prem.",
          "preview": {},
          "optionsDefinitions": {},
          "libraryId": "perpvscoinbase"
        },
        "large-liquidations": {
          "script": "// markers needs a serie to get attached to\r\nline($price.close, color=transparent)\r\n\r\n\r\nif (markers === 0) {\r\n  // first script execution (0 is default values for all persistent variables)\r\n\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // create a var to store already drawn markers\r\n  markers = []\r\n\r\n  // contain the last marker that can change as the bar update\r\n  repaintableMarker = null\r\n\r\n  largeLiquidation = options.largeLiquidation || 3000000\r\n}\r\n\r\nif (repaintableMarker && repaintableMarker.time < time) {\r\n  // bar is +1 since active marker was added, lock it in the array\r\n  markers.push(repaintableMarker)\r\n\r\n  // free up active marker\r\n  repaintableMarker = null\r\n}\r\n\r\nvar newMarker = null\r\n\r\n// BINANCE_FUTURES:btcusdt.lbuy \r\n// BINANCE_FUTURES:btcusdt.lsell \r\nlbuyVolume(10) = source(lbuy, quote=quote,type=type,exchange=exchange)\r\nlsellVolume(10) = source(lsell, quote=quote,type=type,exchange=exchange)\r\n\r\n// big money strategy\r\n// TODO if it has already been on once, don't show\r\nvar signal = sum(lbuyVolume, options.period || 5 ) + sum(lsellVolume,5) > largeLiquidation \r\n\r\nif (signal && !iAmOn) {\r\n  \r\n  // newMarker is a temporary variable (not included in the indicator state)\r\n  // to avoid it being treated as persistent variable we wrap it inside parenthesis\r\n  (newMarker) = {\r\n    time: time,\r\n    position: 'inBar',\r\n    color: (options.markerColor || 'blue'),\r\n    shape: 'square'\r\n  }\r\n\r\n    iAmOn = true\r\n}else if (!signal){\r\n  iAmOn = false\r\n} \r\n\r\nif (newMarker || (repaintableMarker && !newMarker)) {\r\n  // override persistent variable repaintable marker\r\n  repaintableMarker = newMarker\r\n  \r\n  if (series[0].setMarkers) {\r\n    series[0].setMarkers(markers.concat(repaintableMarker))\r\n  }\r\n}",
          "name": "Large Liquidations",
          "priceScaleId": "right",
          "id": "large-liquidations",
          "options": {
            "priceScaleId": "right",
            "largeLiquidation": 4000000,
            "visible": true,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "markerColor": "rgb(77,208,225)",
            "lastValueVisible": false,
            "priceLineVisible": false,
            "baseLineVisible": false,
            "quote": 0,
            "exchange": null,
            "type": "perp",
            "period": 5
          },
          "series": [
            "large-liquidations"
          ],
          "displayName": "Large Liquidations",
          "unsavedChanges": false,
          "optionsDefinitions": {
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            }
          },
          "libraryId": "large-liquidations",
          "createdAt": 1700796224070,
          "updatedAt": 1724741234680
        },
        "spotvsperp": {
          "script": "var binance = (BINANCE:btcusdt.high+BINANCE:btcusdt.low)/2\r\nvar bitfinex = (BITFINEX:BTCUSD.high+BITFINEX:BTCUSD.low)/2\r\n\r\nvar binancePerp = (BINANCE_FUTURES:btcusdt.high+BINANCE_FUTURES:btcusdt.low)/2\r\nvar bybit = (BYBIT:BTCUSDT.high+BYBIT:BTCUSDT.low)/2\r\n\r\n\r\npremium =  (binancePerp + bybit) / 2 - (binance+bitfinex) / 2\r\nbaseline = 0\r\n\r\nplotcloudarea(\r\n  premium,\r\n  baseline, \r\n  positiveColor=options.topLineColor,\r\n  negativeColor=options.bottomLineColor\r\n)\r\n\r\n//line(bitfinex)",
          "name": "SpotVSPerp",
          "priceScaleId": "right",
          "id": "spotvsperp",
          "options": {
            "priceScaleId": "spotvsperp",
            "visible": false,
            "scaleMargins": {
              "top": 0.87,
              "bottom": 0.08
            },
            "negativeLineColor": "rgba(255,235,59,0)",
            "negativeColor": "rgba(255,241,118,0.86)",
            "positiveLineColor": "rgba(255,255,255,0.86)",
            "baseLineVisible": false,
            "positiveColor": "rgba(255,255,255,0.86)",
            "lastValueVisible": true,
            "priceLineVisible": true,
            "topLineColor": "rgb(149,152,161)",
            "bottomLineColor": "rgb(255,238,88)"
          },
          "series": [
            "spotvsperp"
          ],
          "displayName": "SpotVSPerp",
          "unsavedChanges": false,
          "optionsDefinitions": {},
          "libraryId": "spotvsperp",
          "createdAt": 1700847615822,
          "updatedAt": 1714085696486
        },
        "trades": {
          "script": "plotline(cbuy+csell)",
          "id": "trades",
          "name": "trades",
          "options": {
            "priceScaleId": "trades",
            "scaleMargins": {
              "top": 0.67,
              "bottom": 0.29
            },
            "color": "rgba(255,255,255,0.43)",
            "visible": false
          },
          "description": null,
          "createdAt": 1700861665246,
          "updatedAt": 1700861665246,
          "unsavedChanges": false,
          "series": [
            "trades"
          ],
          "displayName": "trades",
          "optionsDefinitions": {}
        },
        "top-bands-spots": {
          "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n}\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\nlevels.bids.sort( (a, b) => a[0] - b[0] )\r\nlevels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nvar alpha1 = startOpacity + (1 - startOpacity) * ((levels.bids[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha1Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color1base = levels.bids[0][1] > level0 ? colorLevel0 : levels.bids[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar color1 = 'rgba(' + color1base.join(',') + ',' + alpha1Rounded + ')'\r\n\r\nvar alpha2 = startOpacity + (1 - startOpacity) * ((levels.bids[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha2Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color2base = levels.bids[1][1] > level0 ? colorLevel0 : levels.bids[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar color2 = 'rgba(' + color2base.join(',') + ',' + alpha2Rounded + ')'\r\n\r\nvar alpha3 = startOpacity + (1 - startOpacity) * ((levels.bids[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha3Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color3base = levels.bids[2][1] > level0 ? colorLevel0 : levels.bids[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar color3 = 'rgba(' + color3base.join(',') + ',' + alpha3Rounded + ')'\r\n\r\nvar alpha4 = startOpacity + (1 - startOpacity) * ((levels.bids[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha4Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color4base = levels.bids[3][1] > level0 ? colorLevel0 : levels.bids[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar color4 = 'rgba(' + color4base.join(',') + ',' + alpha4Rounded + ')'\r\n\r\nvar alpha5 = startOpacity + (1 - startOpacity) * ((levels.bids[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha5Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color5base = levels.bids[4][1] > level0 ? colorLevel0 : levels.bids[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar color5 = 'rgba(' + color5base.join(',') + ',' + alpha5Rounded + ')'\r\n\r\nif( levels.bids[0][1] > minVolume && (levels.bids[0][0] >= bottomLimit && levels.bids[0][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[0] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[0][0],\r\n      higherValue: levels.bids[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[1][1] > minVolume && (levels.bids[1][0] >= bottomLimit && levels.bids[1][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[1] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[1][0],\r\n      higherValue: levels.bids[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[2][1] > minVolume && (levels.bids[2][0] >= bottomLimit && levels.bids[2][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[2] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[2][0],\r\n      higherValue: levels.bids[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[3][1] > minVolume && (levels.bids[3][0] >= bottomLimit && levels.bids[3][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[3] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[3][0],\r\n      higherValue: levels.bids[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[4][1] > minVolume && (levels.bids[4][0] >= bottomLimit && levels.bids[4][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[4] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[4][0],\r\n      higherValue: levels.bids[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nvar alphaAsks1 = startOpacity + (1 - startOpacity) * ((levels.asks[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks1Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks1base = levels.asks[0][1] > level0 ? colorLevel0 : levels.asks[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks1 = 'rgba(' + colorAsks1base.join(',') + ',' + alphaAsks1Rounded + ')'\r\n\r\nvar alphaAsks2 = startOpacity + (1 - startOpacity) * ((levels.asks[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks2Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks2base = levels.asks[1][1] > level0 ? colorLevel0 : levels.asks[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks2 = 'rgba(' + colorAsks2base.join(',') + ',' + alphaAsks2Rounded + ')'\r\n\r\nvar alphaAsks3 = startOpacity + (1 - startOpacity) * ((levels.asks[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks3Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks3base = levels.asks[2][1] > level0 ? colorLevel0 : levels.asks[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks3 = 'rgba(' + colorAsks3base.join(',') + ',' + alphaAsks3Rounded + ')'\r\n\r\nvar alphaAsks4 = startOpacity + (1 - startOpacity) * ((levels.asks[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks4Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks4base = levels.asks[3][1] > level0 ? colorLevel0 : levels.asks[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks4 = 'rgba(' + colorAsks4base.join(',') + ',' + alphaAsks4Rounded + ')'\r\n\r\nvar alphaAsks5 = startOpacity + (1 - startOpacity) * ((levels.asks[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks5Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks5base = levels.asks[4][1] > level0 ? colorLevel0 : levels.asks[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks5 = 'rgba(' + colorAsks5base.join(',') + ',' + alphaAsks5Rounded + ')'\r\n\r\n\r\nif( levels.asks[0][1] > minVolume  && (levels.asks[0][0] >= bottomLimit && levels.asks[0][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[5] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[0][0],\r\n      higherValue: levels.asks[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[1][1] > minVolume && (levels.asks[1][0] >= bottomLimit && levels.asks[1][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[6] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[1][0],\r\n      higherValue: levels.asks[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[2][1] > minVolume && (levels.asks[2][0] >= bottomLimit && levels.asks[2][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[7] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[2][0],\r\n      higherValue: levels.asks[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[3][1] > minVolume && (levels.asks[3][0] >= bottomLimit && levels.asks[3][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[8] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[3][0],\r\n      higherValue: levels.asks[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[4][1] > minVolume && (levels.asks[4][0] >= bottomLimit && levels.asks[4][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[9] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[4][0],\r\n      higherValue: levels.asks[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nreturn\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[0][0] + moveTo, higherValue: levels.bids[0][0] + bandSize + moveTo, color: color1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[1][0] + moveTo, higherValue: levels.bids[1][0] + bandSize + moveTo, color: color2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[2][0] + moveTo, higherValue: levels.bids[2][0] + bandSize + moveTo, color: color3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[3][0] + moveTo, higherValue: levels.bids[3][0] + bandSize + moveTo, color: color4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[4][0] + moveTo, higherValue: levels.bids[4][0] + bandSize + moveTo, color: color5 } )\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[0][0] + moveTo, higherValue: levels.asks[0][0] + bandSize + moveTo, color: colorAsks1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[1][0] + moveTo, higherValue: levels.asks[1][0] + bandSize + moveTo, color: colorAsks2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[2][0] + moveTo, higherValue: levels.asks[2][0] + bandSize + moveTo, color: colorAsks3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[3][0] + moveTo, higherValue: levels.asks[3][0] + bandSize + moveTo, color: colorAsks4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[4][0] + moveTo, higherValue: levels.asks[4][0] + bandSize + moveTo, color: colorAsks5 } )",
          "name": "Top Bands Spots",
          "priceScaleId": "right",
          "id": "top-bands-spots",
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false,
            "colorLevels": "rgb(255,255,255)",
            "colorLevel1": "rgba(255,255,255,0.94)",
            "colorLevel0": "rgba(255,235,59,0.96)",
            "colorLevel": "rgba(120,123,134,0.83)",
            "level0": 700,
            "level1": 400,
            "maxVolume": 1500,
            "minVolume": 200,
            "startOpacity": 0.4,
            "togglePerp": false,
            "bandSize": 30,
            "lastValueVisible": false,
            "color": "rgb(76,175,80)",
            "limitPercent": 6,
            "priceLineVisible": false
          },
          "series": [
            "top-bands-spots",
            "z3h9589a",
            "wqpgej9w",
            "zec94iea",
            "44bm56ca",
            "zo5hy1xe",
            "d0iw8jhn",
            "hyfvil7p",
            "b517xs4l",
            "glc1cc4c"
          ],
          "displayName": "Top Bands Spots",
          "unsavedChanges": true,
          "optionsDefinitions": {},
          "libraryId": "top-bands-spots",
          "createdAt": 1701117407838,
          "updatedAt": 1710455353789
        },
        "ob-speed": {
          "script": "obUpdates = ORDERBOOK:AGGRSPOT-BTCUSD.zupdates + ORDERBOOK:AGGRPERP-BTCUSD.zupdates\r\n\r\nplothistogram(obUpdates)\r\nline(ema(obUpdates, 21))",
          "name": "OB speed",
          "priceScaleId": "ob-speed",
          "id": "ob-speed",
          "options": {
            "priceScaleId": "ob-speed",
            "scaleMargins": {
              "top": 0.62,
              "bottom": 0.33
            },
            "visible": false,
            "togglePerp": true,
            "toggleSpot": true,
            "priceFormat": {
              "type": "volume",
              "precision": 2,
              "minMove": 0.01,
              "auto": true
            }
          },
          "series": [
            "ob-speed",
            "dhmbadlx"
          ],
          "displayName": "OB speed",
          "unsavedChanges": false,
          "preview": {},
          "createdAt": 1701126916031,
          "updatedAt": 1701165614665,
          "optionsDefinitions": {}
        },
        "alerts": {
          "script": "// markers needs a serie to get attached to\r\ncandlestick($price, color=transparent)\r\n\r\nif (markers === 0) {\r\n  // first script execution (0 is default values for all persistent variables)\r\n\r\n  // create a var to store already drawn markers\r\n  markers = []\r\n\r\n  // contain the last marker that can change as the bar update\r\n  repaintableMarker = null\r\n}\r\n\r\nif (repaintableMarker && repaintableMarker.time < time) {\r\n  // bar is +1 since active marker was added, lock it in the array\r\n  markers.push(repaintableMarker)\r\n\r\n  // free up active marker\r\n  repaintableMarker = null\r\n}\r\n\r\nvar newMarker = null\r\nvar myalert = ORDERBOOK:AGGRSPOT-BTCUSDALERTS.zalert\r\n\r\nif( myalert && myalert.length ) {\r\n  //console.log(myalert)\r\n  // big money strategy\r\n  var bearSignal = myalert[2] == 'sell'\r\n  var bullSignal = myalert[2] == 'buy'\r\n\r\n  if (bearSignal) {\r\n    var myColor5 = 'grey'\r\n    if( myalert[3] === 'strong' ){\r\n      myColor5 = 'orange'\r\n    } else if (myalert[3] === 'vstrong' ){\r\n      myColor5 = 'red'\r\n    } else if (myalert[3] === 'ultimate' ){\r\n      myColor5 = 'purple'\r\n    }\r\n    //myColor1 = myalert[3] === 'strong' ? 'red' : 'orange'\r\n\r\n    // newMarker is a temporary variable (not included in the indicator state)\r\n    // to avoid it being treated as persistent variable we wrap it inside parenthesis\r\n    (newMarker) = {\r\n      time: time,\r\n      position: 'aboveBar',\r\n      color: myColor5,\r\n      shape: 'arrowDown',\r\n    }\r\n  }\r\n\r\n  if (bullSignal) {\r\n    var myColor2 = 'grey'\r\n    if( myalert[3] === 'strong' ){\r\n      myColor2 = 'yellow'\r\n    } else if( myalert[3] === 'vstrong' ){\r\n      myColor2 = 'green'\r\n    } else if( myalert[3] === 'ultimate' ){\r\n      myColor2 = 'purple'\r\n    }\r\n\r\n    (newMarker) = {\r\n      time: time,\r\n      position: 'belowBar',\r\n      color:  myColor2,\r\n      shape: 'arrowUp',\r\n    }\r\n  }\r\n}\r\n\r\nif (newMarker || (repaintableMarker && !newMarker)) {\r\n  // override persistent variable repaintable marker\r\n  repaintableMarker = newMarker\r\n  \r\n  if (series[0].setMarkers) {\r\n    series[0].setMarkers(markers.concat(repaintableMarker))\r\n  }\r\n}",
          "name": "Alerts",
          "priceScaleId": "right",
          "id": "alerts",
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false
          },
          "series": [
            "alerts"
          ],
          "displayName": "Alerts",
          "unsavedChanges": false,
          "optionsDefinitions": {},
          "libraryId": "alerts",
          "createdAt": 1701316392533,
          "updatedAt": 1713306835726
        },
        "volume": {
          "script": "if (upColor === 0) {\r\n  if (options.showDelta) {\r\n    upColor = options.upBgColor\r\n    downColor = options.downBgColor\r\n  } else {\r\n    upColor = options.upColor\r\n    downColor = options.downColor\r\n  }\r\n}\r\n\r\nvar _vbuy = source(vbuy, type=perp)\r\nvar _vsell = source(vsell, type=perp)\r\n\r\nif (options.showDelta) {\r\n  plothistogram({ time: time, value: Math.abs(_vbuy-_vsell), color: _vbuy - _vsell > 0 ? options.upColor : options.downColor})\r\n}\r\n\r\nplothistogram({ time: time, value: _vbuy + _vsell, color: _vbuy > _vsell ? upColor : downColor })",
          "enabled": true,
          "name": "Volume",
          "description": "Volume + delta",
          "options": {
            "priceScaleId": "volume",
            "priceFormat": {
              "type": "volume"
            },
            "upColor": "rgba(76,175,80,0.97)",
            "downColor": "rgba(242,54,69,0.97)",
            "scaleMargins": {
              "top": 0.88,
              "bottom": 0
            },
            "showDelta": true,
            "upBgColor": "rgba(178,181,190,0.55)",
            "downBgColor": "rgba(93,96,107,0.58)",
            "visible": true,
            "lastValueVisible": false,
            "color": "rgba(195,168,122,0.54)",
            "showDeltaOnly": true,
            "showBoth": true
          },
          "id": "volume",
          "createdAt": 1700269685372,
          "updatedAt": 1701389128589,
          "series": [
            "volume",
            "geh1jhyw"
          ],
          "unsavedChanges": true,
          "preview": {},
          "displayName": "Volume",
          "optionsDefinitions": {}
        },
        "top-bands-perps": {
          "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n}\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\nlevels.bids.sort( (a, b) => a[0] - b[0] )\r\nlevels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nvar alpha1 = startOpacity + (1 - startOpacity) * ((levels.bids[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha1Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color1base = levels.bids[0][1] > level0 ? colorLevel0 : levels.bids[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar color1 = 'rgba(' + color1base.join(',') + ',' + alpha1Rounded + ')'\r\n\r\nvar alpha2 = startOpacity + (1 - startOpacity) * ((levels.bids[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha2Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color2base = levels.bids[1][1] > level0 ? colorLevel0 : levels.bids[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar color2 = 'rgba(' + color2base.join(',') + ',' + alpha2Rounded + ')'\r\n\r\nvar alpha3 = startOpacity + (1 - startOpacity) * ((levels.bids[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha3Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color3base = levels.bids[2][1] > level0 ? colorLevel0 : levels.bids[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar color3 = 'rgba(' + color3base.join(',') + ',' + alpha3Rounded + ')'\r\n\r\nvar alpha4 = startOpacity + (1 - startOpacity) * ((levels.bids[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha4Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color4base = levels.bids[3][1] > level0 ? colorLevel0 : levels.bids[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar color4 = 'rgba(' + color4base.join(',') + ',' + alpha4Rounded + ')'\r\n\r\nvar alpha5 = startOpacity + (1 - startOpacity) * ((levels.bids[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alpha5Rounded = Math.round(alpha1 * 100) / 100 \r\nvar color5base = levels.bids[4][1] > level0 ? colorLevel0 : levels.bids[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar color5 = 'rgba(' + color5base.join(',') + ',' + alpha5Rounded + ')'\r\n\r\nif( levels.bids[0][1] > minVolume && (levels.bids[0][0] >= bottomLimit && levels.bids[0][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[0] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[0][0],\r\n      higherValue: levels.bids[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[1][1] > minVolume && (levels.bids[1][0] >= bottomLimit && levels.bids[1][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[1] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[1][0],\r\n      higherValue: levels.bids[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[2][1] > minVolume && (levels.bids[2][0] >= bottomLimit && levels.bids[2][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[2] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[2][0],\r\n      higherValue: levels.bids[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[3][1] > minVolume && (levels.bids[3][0] >= bottomLimit && levels.bids[3][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[3] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[3][0],\r\n      higherValue: levels.bids[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.bids[4][1] > minVolume && (levels.bids[4][0] >= bottomLimit && levels.bids[4][0] <= topLimit) ){\r\n    renderer.indicators[indicatorId].series[4] = {\r\n      time: time ,\r\n      lowerValue: levels.bids[4][0],\r\n      higherValue: levels.bids[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nvar alphaAsks1 = startOpacity + (1 - startOpacity) * ((levels.asks[0][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks1Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks1base = levels.asks[0][1] > level0 ? colorLevel0 : levels.asks[0][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks1 = 'rgba(' + colorAsks1base.join(',') + ',' + alphaAsks1Rounded + ')'\r\n\r\nvar alphaAsks2 = startOpacity + (1 - startOpacity) * ((levels.asks[1][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks2Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks2base = levels.asks[1][1] > level0 ? colorLevel0 : levels.asks[1][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks2 = 'rgba(' + colorAsks2base.join(',') + ',' + alphaAsks2Rounded + ')'\r\n\r\nvar alphaAsks3 = startOpacity + (1 - startOpacity) * ((levels.asks[2][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks3Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks3base = levels.asks[2][1] > level0 ? colorLevel0 : levels.asks[2][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks3 = 'rgba(' + colorAsks3base.join(',') + ',' + alphaAsks3Rounded + ')'\r\n\r\nvar alphaAsks4 = startOpacity + (1 - startOpacity) * ((levels.asks[3][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks4Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks4base = levels.asks[3][1] > level0 ? colorLevel0 : levels.asks[3][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks4 = 'rgba(' + colorAsks4base.join(',') + ',' + alphaAsks4Rounded + ')'\r\n\r\nvar alphaAsks5 = startOpacity + (1 - startOpacity) * ((levels.asks[4][1] - minVolume) / (maxVolume - minVolume))\r\nvar alphaAsks5Rounded = Math.round(alphaAsks1 * 100) / 100 \r\nvar colorAsks5base = levels.asks[4][1] > level0 ? colorLevel0 : levels.asks[4][1] > level1 ? colorLevel1 : colorLevel\r\nvar colorAsks5 = 'rgba(' + colorAsks5base.join(',') + ',' + alphaAsks5Rounded + ')'\r\n\r\n\r\nif( levels.asks[0][1] > minVolume  && (levels.asks[0][0] >= bottomLimit && levels.asks[0][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[5] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[0][0],\r\n      higherValue: levels.asks[0][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[1][1] > minVolume && (levels.asks[1][0] >= bottomLimit && levels.asks[1][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[6] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[1][0],\r\n      higherValue: levels.asks[1][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[2][1] > minVolume && (levels.asks[2][0] >= bottomLimit && levels.asks[2][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[7] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[2][0],\r\n      higherValue: levels.asks[2][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[3][1] > minVolume && (levels.asks[3][0] >= bottomLimit && levels.asks[3][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[8] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[3][0],\r\n      higherValue: levels.asks[3][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nif( levels.asks[4][1] > minVolume && (levels.asks[4][0] >= bottomLimit && levels.asks[4][0] <= topLimit)){\r\n    renderer.indicators[indicatorId].series[9] = {\r\n      time: time ,\r\n      lowerValue: levels.asks[4][0],\r\n      higherValue: levels.asks[4][0] + bandSize,\r\n      color: color1\r\n    }\r\n}\r\n\r\nreturn\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[0][0] + moveTo, higherValue: levels.bids[0][0] + bandSize + moveTo, color: color1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[1][0] + moveTo, higherValue: levels.bids[1][0] + bandSize + moveTo, color: color2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[2][0] + moveTo, higherValue: levels.bids[2][0] + bandSize + moveTo, color: color3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[3][0] + moveTo, higherValue: levels.bids[3][0] + bandSize + moveTo, color: color4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.bids[4][0] + moveTo, higherValue: levels.bids[4][0] + bandSize + moveTo, color: color5 } )\r\n\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[0][0] + moveTo, higherValue: levels.asks[0][0] + bandSize + moveTo, color: colorAsks1 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[1][0] + moveTo, higherValue: levels.asks[1][0] + bandSize + moveTo, color: colorAsks2 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[2][0] + moveTo, higherValue: levels.asks[2][0] + bandSize + moveTo, color: colorAsks3 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[3][0] + moveTo, higherValue: levels.asks[3][0] + bandSize + moveTo, color: colorAsks4 } )\r\nplotbrokenarea({ time: time, lowerValue: levels.asks[4][0] + moveTo, higherValue: levels.asks[4][0] + bandSize + moveTo, color: colorAsks5 } )",
          "name": "Top Bands Perps",
          "priceScaleId": "right",
          "id": "top-bands-perps",
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false,
            "colorLevels": "rgb(255,255,255)",
            "colorLevel1": "rgba(41,98,255,0.91)",
            "colorLevel0": "rgb(242,54,69)",
            "colorLevel": "rgba(91,156,246,0.79)",
            "level0": 1900,
            "level1": 1600,
            "maxVolume": 3500,
            "minVolume": 600,
            "startOpacity": 0.3,
            "togglePerp": true,
            "bandSize": 25,
            "limitPercent": 5,
            "priceLineVisible": false,
            "baseLineVisible": false
          },
          "series": [
            "top-bands-perps",
            "9jkfmyai",
            "2ne6r2h4",
            "njvvbr85",
            "qff8exef",
            "uuzbt6zg",
            "ogtunkl7",
            "xei84azk",
            "itjo6qob",
            "a6vjvk8t"
          ],
          "displayName": "Top Bands Perps",
          "unsavedChanges": true,
          "optionsDefinitions": {},
          "libraryId": "top-bands-perps",
          "createdAt": 1702374821392,
          "updatedAt": 1710455365119
        },
        "overlays-all": {
          "script": "if (!pendingMarkers) {\r\n    // runs only once\r\n    lastIndex = null\r\n    pendingMarkers = []\r\n    spotColor = options.spotColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    perpColor = options.perpColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    binanceColor = options.binanceColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    coinbaseColor = options.coinbaseColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    bitmexColor = options.bitmexColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1, 5).map(a => +a);\r\n\r\n    //allOnColor = options.allOnColor.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    spotOpacity = spotColor.pop()\r\n    perpOpacity = perpColor.pop()\r\n    binanceOpacity = binanceColor.pop()\r\n    coinbaseOpacity = coinbaseColor.pop()\r\n    bitmexOpacity = bitmexColor.pop()\r\n   // allOnColorOpacity = allOnColor.pop()\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n  \r\n    spotBuyAlerts  = [40, 63, 46, 60]\r\n    spotSellAlerts = [-40, -63, -46, -60]\r\n\r\n    perpBuyAlerts  = [37, 27, 36, 35]\r\n    perpSellAlerts = [-20, -27, -36, -35]\r\n\r\n    binanceBuyAlerts  = [70, 70, 70, 70]\r\n    binanceSellAlerts = [-70, -70, -70, -70]\r\n\r\n    coinbaseBuyAlerts  = [50, 50, 50, 50]\r\n    coinbaseSellAlerts = [-50, -70, -65, -50]\r\n\r\n    bitmexBuyAlerts  = [-50, -60, -50, -50]\r\n    bitmexSellAlerts = [-50, -60, -50, -50]\r\n\r\n    alerts = {\r\n      spot: {\r\n        buy: spotBuyAlerts,\r\n        sell: spotSellAlerts\r\n      },\r\n      perp: {\r\n        buy: perpBuyAlerts,\r\n        sell: perpSellAlerts\r\n      },\r\n      binance: {\r\n        buy: binanceBuyAlerts,\r\n        sell: binanceSellAlerts\r\n      },\r\n      coinbase: {\r\n        buy: coinbaseBuyAlerts,\r\n        sell: coinbaseSellAlerts\r\n      },\r\n        bitmex: {\r\n            buy: bitmexBuyAlerts,\r\n            sell: bitmexSellAlerts\r\n        }\r\n    }\r\n\r\n    whichColors = {\r\n      spot: spotColor,\r\n      perp: perpColor,\r\n      binance: binanceColor,\r\n      coinbase: coinbaseColor,\r\n      bitmex: bitmexColor\r\n    }\r\n\r\n    allOnIndicator = options.toggleAllOnIndicator || false,\r\n    allOnMinusOne = options.toggleAllOnMinusOne || false,\r\n\r\n    showType = {\r\n      spot: options.toggleSpot,\r\n      perp: options.togglePerp,\r\n      binance: options.toggleBinance,\r\n      coinbase: options.toggleCoinbase,\r\n      bitmex: options.toggleBitmex\r\n    }\r\n\r\n    showBand = [\r\n        options.toggleBand1 || false,\r\n        options.toggleBand2 || false,\r\n        options.toggleBand3 || false,\r\n        options.toggleBand4 || false,\r\n    ]\r\n\r\n    bitmexSmallerBand = options.toggleBitmexSmallerBand || false\r\n\r\n    lowerPercent = [options.band0lowerPercent || 0.11, 1, 2.5, 5]\r\n    upperPercent = [1, 2.5, 5, 10]  \r\n\r\n  }\r\n  // </STARTUP SCRIPT> \r\n\r\n// process only on new candle\r\nif (bar.length === lastIndex) {\r\n  return\r\n}\r\n\r\n  var ratiosPerp = ORDERBOOK:AGGRPERP-BTCUSD.zratios\r\n  var ratiosSpot = ORDERBOOK:AGGRSPOT-BTCUSD.zratios \r\n  var ratiosBinance = renderer.sources['ORDERBOOK:BINANCE-BTCUSDT'] && renderer.sources['ORDERBOOK:BINANCE-BTCUSDT'].zratios\r\n  var ratiosCoinbase = renderer.sources['ORDERBOOK:COINBASE-BTCUSD'] && renderer.sources['ORDERBOOK:COINBASE-BTCUSD'].zratios \r\n  var ratiosBitmex = renderer.sources['ORDERBOOK:BITMEX-XBTUSD'] && renderer.sources['ORDERBOOK:BITMEX-XBTUSD'].zratios\r\n\r\n  var m = [\r\n      { which: 'perp', ratios: ratiosPerp || [], bands: [] },\r\n      { which: 'spot', ratios: ratiosSpot || [], bands: [] },\r\n      { which: 'binance', ratios: ratiosBinance || [], bands: [] },\r\n      { which: 'coinbase', ratios: ratiosCoinbase || [], bands: [] },\r\n      { which: 'bitmex', ratios: ratiosBitmex || [], bands: [] }\r\n  ];\r\n\r\n  // for each ratio\r\n  for(let ratioIndex = 0; ratioIndex < 4; ratioIndex++){\r\n\r\n    // TODO must be same direction\r\n    var allOn = true;\r\n    var allowMinusOne = allOnMinusOne;\r\n\r\n    // for each type (perp, spot, binance, ...)\r\n    for(let typeIndex = 0; typeIndex < m.length; typeIndex++){\r\n\r\n      var c = m[typeIndex]\r\n\r\n      if( showBand[ratioIndex] === false || showType[c.which]  === false ){\r\n        c.bands.push([0, 0, '']) \r\n        continue\r\n      }\r\n        \r\n      var ratio = c.ratios.length && c.ratios[ratioIndex]\r\n      var direction = Math.sign(ratio)\r\n      var buyAlert = alerts[c.which]['buy'][ratioIndex]\r\n      var sellAlert = alerts[c.which]['sell'][ratioIndex]\r\n      var threshold = direction > 0 ? buyAlert : sellAlert\r\n      var thresholdAbs = Math.abs(threshold)\r\n    \r\n      var smaller = bitmexSmallerBand && c.which === 'bitmex' ? 2000 : 0;\r\n      var lower = $price.close + -1 * direction * (($price.close  * lowerPercent[ratioIndex]) / 100) + direction * smaller \r\n      var upper = $price.close + -1 * direction * (($price.close  * upperPercent[ratioIndex]) / 100) + direction * smaller \r\n\r\n      if( !ratio || Math.abs(ratio) < thresholdAbs ){\r\n          allOn = allowMinusOne ? true : false\r\n          allowMinusOne = false\r\n          c.bands.push([0, 0, '']) \r\n      }else{\r\n\r\n          var alphaRatio = Math.abs(ratio) < thresholdAbs ? 0 : startOpacity + (1 - startOpacity) * ((Math.abs(ratio) - thresholdAbs) / (100 - thresholdAbs))\r\n          var alphaRatioRounded = Math.round(alphaRatio * 100) / 100 \r\n          var colorRatio = 'rgba(' + whichColors[c.which].join(',') + ',' + alphaRatioRounded + ')'\r\n          \r\n          c.bands.push([lower, upper, colorRatio])\r\n      }\r\n      \r\n    }// end for each type\r\n\r\n    if( allOnIndicator && allOn ){\r\n      for(let typeIndex = 0; typeIndex < 4; typeIndex++){\r\n        var c = m[typeIndex]\r\n        c.bands[ratioIndex] = [lower, upper, options.allOnColor]\r\n      }\r\n    }\r\n\r\n  } // end for each ratios\r\n\r\n\r\nvar i = 0\r\n\r\nfor(let ratioIndex = 0; ratioIndex < 4; ratioIndex++){\r\n\r\n    if( showBand[ratioIndex] === false ){\r\n      i = i + m.length\r\n      continue\r\n    }\r\n\r\n    for(let typeIndex = 0; typeIndex < m.length; typeIndex++){\r\n\r\n       var c = m[typeIndex]\r\n       \r\n       if( c.bands.length && c.bands[ratioIndex][0] !== 0 ) {\r\n         renderer.indicators[indicatorId].series[i] = {\r\n          time: time, \r\n          lowerValue: c.bands[ratioIndex][0],\r\n          higherValue: c.bands[ratioIndex][1],\r\n          color:  c.bands[ratioIndex][2]\r\n        }\r\n      }\r\n\r\n      i++\r\n    }\r\n}\r\n\r\n// set reference to bar index : avoid process next tick\r\nlastIndex = bar.length\r\n\r\nreturn\r\n//perp\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })     \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })   \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })   \r\n      brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\n            brokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })\r\nbrokenarea({\r\n        time: time, \r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        color:  options.color\r\n      })",
          "name": "Overlays All",
          "priceScaleId": "right",
          "id": "overlays-all",
          "options": {
            "priceScaleId": "right",
            "startOpacity": "",
            "toggleAllOnIndicator": true,
            "toggleSpot": true,
            "togglePerp": true,
            "toggleBinance": true,
            "toggleCoinbase": true,
            "toggleBitmex": true,
            "toggleBand1": true,
            "toggleBand2": true,
            "toggleBand3": true,
            "toggleBand4": true,
            "spotColor": "rgb(255,235,59)",
            "perpColor": "rgb(41,98,255)",
            "binanceColor": "rgb(255,255,255)",
            "coinbaseColor": "rgb(250,161,164)",
            "bitmexColor": "rgb(171,71,188)",
            "allOnColor": "rgb(242,54,69)",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "band0lowerPercent": null,
            "visible": false,
            "toggleBitmexSmallerBand": false,
            "allOnMinusOne": null,
            "toggleAllOnMinusOne": false
          },
          "optionsDefinitions": {},
          "series": [
            "overlays-all",
            "u6881fc2",
            "opqjkn2w",
            "53bgsyqp",
            "5cyv6bq8",
            "ih4wqi9n",
            "7leceb06",
            "oof83rr1",
            "ygvao2li",
            "go8iy1g4",
            "64bevrib",
            "r0i3g968",
            "nbbs5r8n",
            "gcqfrbs3",
            "xd5korqu",
            "zphhmr3n",
            "3t3ezcqx",
            "fvj18tdt",
            "oxegu4ns",
            "34cklaoo"
          ],
          "displayName": "Overlays All",
          "unsavedChanges": true,
          "libraryId": "overlays-all",
          "createdAt": 1703209928644,
          "updatedAt": 1713657464427
        },
        "averages": {
          "script": "var price = (BINANCE_FUTURES:btcusdt.high + BINANCE_FUTURES:btcusdt.low + BINANCE_FUTURES:btcusdt.close) / 3\r\nvar sumPV = sum((BINANCE_FUTURES:btcusdt.vsell + BINANCE_FUTURES:btcusdt.vbuy) * (BINANCE_FUTURES:btcusdt.high + BINANCE_FUTURES:btcusdt.low + BINANCE_FUTURES:btcusdt.close) / 3 , options.vwmaLength)\r\nvar sumV = sum((BINANCE_FUTURES:btcusdt.vsell + BINANCE_FUTURES:btcusdt.vbuy), options.vwmaLength)\r\n\r\nline(ema(price, options.emaLength))\r\n\r\nline(sumPV / sumV, color = options.vwmaColor)",
          "name": "Averages",
          "priceScaleId": "right",
          "id": "averages",
          "options": {
            "priceScaleId": "right",
            "color": "rgba(178,40,51,0.5)",
            "vwma": null,
            "vwmaColor": "rgba(251,192,45,0.75)",
            "visible": false,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "vwmaLength": 21,
            "emaLength": 121
          },
          "optionsDefinitions": {},
          "series": [
            "averages",
            "wx9ask3f"
          ],
          "displayName": "Averages",
          "unsavedChanges": true
        },
        "bollinger-bands": {
          "script": "var a = sma(Math.pow($price.close,2),options.length)\nvar b = Math.pow(sum($price.close,options.length),2)/Math.pow(options.length,2)\nvar stdev = Math.sqrt(a - b)\nvar src = $price.close\n\nvar basis = sma($price.close, options.length)\nvar dev = options.mult * stdev\nupper = basis + dev\nlower = basis - dev\n\nplotline(basis, color=options.basisColor)\nplotcloudarea(lower, upper)",
          "id": "bollinger-bands",
          "name": "Bollinger Bands",
          "options": {
            "priceScaleId": "right",
            "mult": 3,
            "length": 120,
            "lineStyle": 2,
            "basisColor": "rgba(129,199,132,0.5)",
            "positiveColor": "rgba(0,0,0,0.1)",
            "negativeColor": "rgba(0,0,0,0.1)",
            "lowerLineColor": "rgb(129,199,132)",
            "higherLineColor": "rgb(129,199,132)",
            "priceLineVisible": false,
            "lastValueVisible": true,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false
          },
          "description": null,
          "createdAt": 1683892675452,
          "updatedAt": 1705183212240,
          "unsavedChanges": false,
          "optionsDefinitions": {},
          "series": [
            "bollinger-bands",
            "sqojd6ts"
          ],
          "displayName": "Bollinger Bands",
          "libraryId": "bollinger-bands"
        },
        "_f8i6stuml3q7zwkc": {
          "id": "_f8i6stuml3q7zwkc",
          "libraryId": "cvd-binance",
          "name": "CVD Binance",
          "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
          "createdAt": 1705025291244,
          "updatedAt": 1706057087744,
          "options": {
            "priceScaleId": "_v9ix9ggm0looumtf",
            "scaleMargins": {
              "top": 0.04,
              "bottom": 0.8
            },
            "bodyPercentWatch": null,
            "wickRatioThreshold": null,
            "toggleDebug": null,
            "toggleVolumeWick": null,
            "togglePrintNormalObv": null,
            "toggleRefine": null,
            "showDivs": true,
            "pivotLeftLength": 50,
            "pivotRightLength": 50,
            "ppCheck": 3,
            "maxbars": null,
            "togglePivotAgo": false,
            "toggleShowPricePivot": false,
            "DivcolorUp": "rgb(255,238,88)",
            "DivcolorDn": "rgb(255,238,88)",
            "cvdColor": "rgb(255,235,59)",
            "quote": 0,
            "exchange": "BINANCE",
            "type": "spot",
            "title": "S",
            "visible": false
          },
          "optionsDefinitions": {
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            }
          },
          "series": [
            "cvd-binance",
            "eqc1if43"
          ],
          "displayName": "CVD Binance",
          "unsavedChanges": false
        },
        "_pngsl31b0gpvtuas": {
          "id": "_pngsl31b0gpvtuas",
          "libraryId": "cvd-coinbase copy 1",
          "name": "CVD Coinbase",
          "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
          "createdAt": 1705025338594,
          "updatedAt": 1710054922560,
          "options": {
            "priceScaleId": "cvd-binance-spot",
            "scaleMargins": {
              "top": 0.04,
              "bottom": 0.8
            },
            "bodyPercentWatch": null,
            "wickRatioThreshold": null,
            "toggleDebug": null,
            "toggleVolumeWick": null,
            "togglePrintNormalObv": null,
            "toggleRefine": null,
            "showDivs": true,
            "pivotLeftLength": 50,
            "pivotRightLength": 50,
            "ppCheck": 3,
            "maxbars": null,
            "togglePivotAgo": false,
            "toggleShowPricePivot": false,
            "DivcolorUp": "rgb(247,124,128)",
            "DivcolorDn": "rgb(247,124,128)",
            "cvdColor": "rgb(247,124,128)",
            "quote": 0,
            "exchange": "COINBASE",
            "type": "spot",
            "title": "C",
            "color": "rgb(250,161,164)",
            "visible": false
          },
          "optionsDefinitions": {
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            }
          },
          "series": [
            "cvd-coinbase copy 1",
            "vm024pxi"
          ],
          "displayName": "CVD Coinbase",
          "unsavedChanges": false
        },
        "_bc6lfhgxb0wc36l9": {
          "id": "_bc6lfhgxb0wc36l9",
          "libraryId": "cvd-binance-p",
          "name": "CVD Binance P",
          "script": "if (pivotsMax === 0) {\r\n  // Source\r\n  quote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\r\n  exchange = option(default=null,type=exchange,rebuild=true)\r\n  type = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\r\n  \r\n  // Pivots\r\n  pivotsMax = 20\r\n  phPositions = []\r\n  plPositions = []\r\n  phVals = []\r\n  plVals = []\r\n}\r\n\r\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\r\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\r\n\r\ncvd = cum(buyVolume - sellVolume)\r\n\r\nplotline(cvd, title=options.title || \"CVD\", color=options.cvdColor)\r\n\r\nif( options.toggleShowPricePivot ){\r\n  plotline(cvd, color=transparent)\r\n}\r\n\r\nif (options.showDivs) {\r\n  \r\n  // <markers utils>\r\n  if (markersDiv === 0) {\r\n    markersDiv = []\r\n  }\r\n  if (markersPivot === 0) {\r\n    markersPivot = []\r\n  }\r\n  \r\n  if (pendingMarkerDiv && pendingMarkerDiv.time < time) {\r\n    markersDiv.push(pendingMarkerDiv)\r\n    pendingMarkerDiv = null\r\n  }\r\n\r\n  if (pendingMarkerPivot && pendingMarkerPivot.time < time) {\r\n    markersPivot.push(pendingMarkerPivot)\r\n    pendingMarkerPivot = null\r\n  }\r\n  \r\n  var newMarkerDiv = null\r\n  var newMarkerPivot = null\r\n  // </markers utils>\r\n  \r\n  // Check if we get new Pivot High Or Pivot Low\r\n\r\n  // find pivots low (cvd and price)\r\n  plCvd = pivot_low(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  plPrice = pivot_low($price.low, options.pivotLeftLength, options.pivotRightLength)\r\n\r\n  // find pivots high (cvd and price)\r\n  phCvd = pivot_high(cvd, options.pivotLeftLength, options.pivotRightLength)\r\n  phPrice = pivot_high($price.high, options.pivotLeftLength, options.pivotRightLength)\r\n  \r\n  if( plPrice ){\r\n    plPositions.unshift(bar.length)\r\n    plVals.unshift(plPrice)\r\n    if( plPositions.length > pivotsMax ){\r\n      plPositions.pop();\r\n      plVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > plPositions.length || plPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - plPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n      \r\n      // Price lower than previous pivot but CVD is higher\r\n      if( len > 5 && plPrice < (plVals[i] || 0) && cvd > cvd[len]){\r\n         console.log('PL', plPositions[i], len, cvd, cvd[len], $price.high, plVals[i])\r\n         foundDiv = true\r\n\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv && options.toggleShowPricePivot){\r\n      newMarkerPivot = {\r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorUp,\r\n          position: 'belowBar',\r\n          //shape: 'arrowUp',\r\n          text:  'L'\r\n        }\r\n    }\r\n  }\r\n\r\n  if( phPrice ){\r\n \r\n    phPositions.unshift(bar.length)\r\n    phVals.unshift(phPrice)\r\n    if( phPositions.length > pivotsMax ){\r\n      phPositions.pop();\r\n      phVals.pop()\r\n    }\r\n\r\n    var foundDiv = false\r\n    var startPoint = 0\r\n    cvd[100] // looks like required to load \r\n    for( var i = 0; i < (options.ppCheck || 10); i++ ){ \r\n      if( i > phPositions.length || phPositions[i] == 0){\r\n        break\r\n      }\r\n      var len = bar.length - phPositions[i] + options.pivotRightLength\r\n      if( len > (options.maxbars || 100)){\r\n        break\r\n      }\r\n\r\n      // Price greater than previous pivot but CVD lower\r\n      if( len > 5 && phPrice > (phVals[i] || Infinity) && cvd < cvd[len]){\r\n         console.log('PH', phPositions[i], len, cvd, cvd[len], $price.high, phVals[i])\r\n        foundDiv = true\r\n         newMarkerDiv = { \r\n          time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n          color: options.DivcolorDn,\r\n          position: 'aboveBar',\r\n          //shape: 'arrowDown',\r\n          text: '' + (options.togglePivotAgo ? i : '')\r\n        }\r\n        break\r\n      }\r\n    }\r\n\r\n    if( !foundDiv  && options.toggleShowPricePivot ){\r\n        newMarkerPivot = { \r\n            time: time - (options.pivotRightLength-1) * bar.timeframe,\r\n            color: options.DivcolorDn,\r\n            position: 'aboveBar',\r\n            //shape: 'arrowDown',\r\n            text: 'H'\r\n          }\r\n    }\r\n  }\r\n  \r\n  // <markers utils>\r\n  if (newMarkerDiv || (pendingMarkerDiv && !newMarkerDiv)) {\r\n      pendingMarkerDiv = newMarkerDiv\r\n    \r\n    if (markersDiv.length > 100) {\r\n        markersDiv.splice(0, 1)\r\n    }\r\n      \r\n    if (series[0].setMarkers) {\r\n      series[0].setMarkers(markersDiv.concat(pendingMarkerDiv))\r\n    }\r\n  }\r\n\r\n  if (newMarkerPivot || (pendingMarkerPivot && !newMarkerPivot)) {\r\n      pendingMarkerPivot = newMarkerPivot\r\n    \r\n    if (markersPivot.length > 100) {\r\n        markersPivot.splice(0, 1)\r\n    }\r\n      \r\n    if (series[1].setMarkers) {\r\n      series[1].setMarkers(markersPivot.concat(pendingMarkerPivot))\r\n    }\r\n  }\r\n\r\n  // </markers utils>\r\n}",
          "createdAt": 1705025447976,
          "updatedAt": 1719778074882,
          "options": {
            "priceScaleId": "_bc6lfhgxb0wc36l9",
            "scaleMargins": {
              "top": 0.04,
              "bottom": 0.8
            },
            "bodyPercentWatch": null,
            "wickRatioThreshold": null,
            "toggleDebug": null,
            "toggleVolumeWick": null,
            "togglePrintNormalObv": null,
            "toggleRefine": null,
            "showDivs": false,
            "pivotLeftLength": 25,
            "pivotRightLength": 25,
            "ppCheck": 3,
            "maxbars": null,
            "togglePivotAgo": false,
            "toggleShowPricePivot": false,
            "DivcolorUp": "rgb(49,121,245)",
            "DivcolorDn": "rgb(49,121,245)",
            "cvdColor": "rgb(49,121,245)",
            "quote": 0,
            "exchange": "BINANCE_FUTURES",
            "type": "perp",
            "title": "P",
            "visible": true
          },
          "optionsDefinitions": {
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            }
          },
          "series": [
            "cvd-binance-p",
            "m78my5c5"
          ],
          "displayName": "CVD Binance P",
          "unsavedChanges": false
        },
        "_oh4jdeuqr3sfb21e": {
          "id": "_oh4jdeuqr3sfb21e",
          "libraryId": "keltner",
          "name": "keltner",
          "description": null,
          "script": "close = BINANCE_FUTURES:btcusdt.close\n\nrange = BINANCE_FUTURES:btcusdt.high - BINANCE_FUTURES:btcusdt.low\naverageRange = sma(range, options.length)\n\nbasis = ema(close, options.length)\ndev = options.mult * averageRange\nupper = basis + dev\nlower = basis - dev\n\nplotline(basis, color=options.basisColor)\nplotcloudarea(lower, upper)",
          "createdAt": 1666924136794,
          "updatedAt": 1705183470830,
          "options": {
            "priceScaleId": "right",
            "length": 30,
            "mult": 4,
            "positiveColor": "rgba(35,37,35,0.1)",
            "negativeColor": "rgba(192,174,174,0.1)",
            "higherLineColor": "rgba(137,141,138,0.25)",
            "lowerLineColor": "rgba(223,210,210,0.16)",
            "basisColor": "rgba(228,224,218,0.34)",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false
          },
          "optionsDefinitions": {},
          "series": [
            "keltner",
            "wshj8aqn"
          ],
          "displayName": "keltner",
          "unsavedChanges": false
        },
        "_my4zvk49em6mh062": {
          "id": "_my4zvk49em6mh062",
          "libraryId": "oi",
          "name": "OI",
          "script": "src = { sources: { \"ORDERBOOK:AGGROI-BTCUSD\":ORDERBOOK:AGGROI-BTCUSD }, localTimestamp: time }\r\n\r\nvar ohlc = options.useHeikinAshi ? avg_heikinashi(src) : options.useGaps ? avg_ohlc_with_gaps(src) : avg_ohlc(src)\r\n\r\nplotcandlestick(ohlc, id=openinterest)",
          "createdAt": 1705463203632,
          "updatedAt": 1713247810872,
          "options": {
            "priceScaleId": "_tdqicpndr092c1gk",
            "priceFormat": {
              "type": "volume",
              "precision": 2,
              "minMove": 0.01,
              "auto": true
            },
            "priceLineVisible": true,
            "lastValueVisible": true,
            "borderVisible": false,
            "upColor": "rgba(255,235,59,0.52)",
            "downColor": "rgba(242,54,69,0.64)",
            "borderUpColor": "rgba(255,245,157,0.66)",
            "borderDownColor": "rgba(178,40,51,0.52)",
            "wickUpColor": "rgb(223,211,144)",
            "wickDownColor": "rgba(239,67,82,0.47)",
            "useGaps": false,
            "useHeikinAshi": false,
            "scaleMargins": {
              "top": 0.21,
              "bottom": 0.69
            },
            "visible": true
          },
          "optionsDefinitions": {},
          "series": [
            "openinterest"
          ],
          "displayName": "OI",
          "unsavedChanges": false
        },
        "_7o282jzm9vulptiq": {
          "id": "_7o282jzm9vulptiq",
          "libraryId": "liquidation-heatmap copy 1",
          "name": "Liquidation Heatmap",
          "description": "Visualizes potential liquidation levels",
          "script": "leverages = option(default=5|20|100,type=text)\nthreshold = option(default=800,type=range,min=100,max=5000,log=true, step=100)\nmaxRange = option(default=2200,type=range,min=100,max=5000,log=true, step=100)\nminDelta = option(default=0,type=range,min=0,max=100,log=true, step=1)\nfadeOut = option(default=0,type=range,min=0,max=1,log=true,step=0.001)\nstepScale = option(default=0.5,type=range,min=0,max=2,step=0.01)\nstepValue = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=50,type=range,min=0,max=100,step=1,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\nsrc = option(default=\"high/low\",type=list,options=[\"open\", \"high\", \"low\", \"close\",\"hl2\",\"ohl3\",\"ohlc4\",\"hlcc4\",\"high/low\",\"low/high\"])\ncolor0 = option(default=rgba(0,0,0,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=20,type=range,min=1,max=200, step=1)\natrLength = option(default=20,type=range,min=1,max=200, step=1)\nuseHK = option(default=true,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=true,type=checkbox)\ndynamicMax = option(default=true,type=checkbox)\nstrokeWidth = option(default=0,type=number,description=\"For debug purpose\")\n\n//var isLastCurrentCandle = new Date().getTime() >= renderer.timestamp && new Date().getTime() <= renderer.timestamp + renderer.timescale;\n\n\nif (!liquidityAtPrices) {\n  // init\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  resistances = []\n  supports = []\n  pendingRedraws = []\n  maxOpened = 0 \n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // bind boundaries reference\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n   return\n}\n\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\npriceRef = price\n\n// grid size\nif (stepValue) {\n  // absolute\n  steps = stepValue\n} else {\n  // calculated with atr\n  var hl = price.high - price.low\n  var hc = Math.abs(price.high - priceRef[1].close)\n  var lc = Math.abs(price.low - priceRef[1].close)\n  var atr = sma(Math.max(hl, hc, lc), atrLength)\n\n  if (bar.length < atrLength) {\n    return\n  }\n\n  if (!steps) {\n    steps = atr * stepScale\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\noi = $openinterest\nvar oiDelta = oi.high - oi.low\n\nvol = buyVolume + sellVolume\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\n\n// custom src\nvar resolvedSrc  = priceRef[1][options.src]\nif (resolvedSrc === undefined) {\n  if (options.src === 'hl2') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low) / 2\n  } else if (options.src === 'ohl3') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low) / 3\n  } else if (options.src === 'ohlc4') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (options.src === 'hlcc4') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low + priceRef[1].close + priceRef[1].close) / 4\n  }\n}\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  if (options.src === 'high/low') {\n    resolvedSrc = lev > 0 ? priceRef[1].high : priceRef[1].low\n  } else if (options.src === 'low/high') {\n    resolvedSrc = lev > 0 ? priceRef[1].low : priceRef[1].high\n  }\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  var lp = (resolvedSrc + resolvedSrc * (100 / lev / 100))\n  \n  // rounded lp median (the cell id)\n  var slp = Math.ceil(lp / steps) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      count: 0,\n      top: top,\n      bottom: bottom\n    }\n    \n    if (lev > 0) {\n        resistances.push(slp)\n        resistances.sort((a, b) => a - b)\n    } else {\n        supports.push(slp)\n        supports.sort((a, b) => b - a)\n    }\n  }\n  \n  // update cell\n  //liquidityAtPrices[slp].count++\n  //liquidityAtPrices[slp].strength += lev > 0 ? sellRatio : buyRatio\n  \n  //var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  if (oiDelta < minDelta) {\n    continue\n  }\n\n  var oiDeltaNormalized = oiDelta / options.threshold\n  var maxOpenedThreshold = dynamicMax && maxOpened > 0 ? maxOpened : options.maxRange\n  var ratio = Math.min(1, (liquidityAtPrices[slp].strength + oiDelta) / maxOpenedThreshold ) * (options.strength / 100)\n  // var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  liquidityAtPrices[slp].count++\n  liquidityAtPrices[slp].strength += oiDelta\n  //ratio = liquidityAtPrices[slp].strength > 0 ? 1 : 0.1\n  liquidityAtPrices[slp].color = interpolate(ratio, color0, color1, color2, color3)\n\n  if (liquidityAtPrices[slp].strength > options.threshold ) {\n    maxOpened = maxOpened > liquidityAtPrices[slp].strength ? maxOpened : liquidityAtPrices[slp].strength\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.push(slp)\n    }\n  }\n}\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length\n      }\n      \n      \n\n      cell.id = Math.random().toString()\n      renderer.indicators[indicatorId].series[usedIndex] ={\n        id: cell.id,\n        time: time,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: cell.color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  if (\n   price.low <= supports[i] || liquidityAtPrices[supports[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[supports[i]].id] = bar.length\n    delete liquidityAtPrices[supports[i]]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[supports[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  if (\n   price.high >= resistances[i] || liquidityAtPrices[resistances[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[resistances[i]].id] = bar.length\n    delete liquidityAtPrices[resistances[i]]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[resistances[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define available series\nif (renderer.indicators[indicatorId].series[0]) {\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[1]) {\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[2]) {\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[3]) {\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[4]) {\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[5]) {\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[6]) {\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[7]) {\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[8]) {\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[9]) {\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[10]) {\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[11]) {\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[12]) {\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[13]) {\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[14]) {\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[15]) {\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[16]) {\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}",
          "createdAt": 1703543399433,
          "updatedAt": 1723074817776,
          "options": {
            "priceScaleId": "right",
            "leverages": "50|100",
            "threshold": 1000,
            "fadeOut": 0,
            "stepScale": 0.52,
            "stepValue": 50,
            "strength": 78,
            "quote": "USDT",
            "exchange": "BINANCE_FUTURES",
            "type": "perp",
            "src": "high/low",
            "volLength": 21,
            "atrLength": 22,
            "useHK": false,
            "useLog": true,
            "strokeWidth": 0,
            "color0": "rgba(194,24,91,0)",
            "color": "rgba(76,175,80,0)",
            "visible": true,
            "lastValueVisible": false,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "max": 100,
            "color1": "rgba(63,16,87,0.79)",
            "color2": "rgba(76,152,134,0.79)",
            "maxRange": 3000,
            "dynamicMax": false,
            "minDelta": 23
          },
          "optionsDefinitions": {
            "leverages": {
              "default": "5|20|100",
              "type": "text"
            },
            "threshold": {
              "default": 800,
              "type": "range",
              "min": 100,
              "max": 5000,
              "log": true,
              "step": 100
            },
            "maxRange": {
              "default": 2200,
              "type": "range",
              "min": 100,
              "max": 5000,
              "log": true,
              "step": 100
            },
            "minDelta": {
              "default": 0,
              "type": "range",
              "min": 0,
              "max": 100,
              "log": true,
              "step": 1
            },
            "fadeOut": {
              "default": 0,
              "type": "range",
              "min": 0,
              "max": 1,
              "log": true,
              "step": 0.001
            },
            "stepScale": {
              "default": 0.5,
              "type": "range",
              "min": 0,
              "max": 2,
              "step": 0.01
            },
            "stepValue": {
              "default": "",
              "type": "text",
              "placeholder": "empty = ATR"
            },
            "strength": {
              "default": 50,
              "type": "range",
              "min": 0,
              "max": 100,
              "step": 1,
              "log": true
            },
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            },
            "src": {
              "default": "high/low",
              "type": "list",
              "options": [
                "open",
                "high",
                "low",
                "close",
                "hl2",
                "ohl3",
                "ohlc4",
                "hlcc4",
                "high/low",
                "low/high"
              ]
            },
            "color0": {
              "default": "rgba(0,0,0,0)",
              "type": "color"
            },
            "color1": {
              "default": "rgb(63,16,87)",
              "type": "color"
            },
            "color2": {
              "default": "rgb(76,152,134)",
              "type": "color"
            },
            "color3": {
              "default": "rgb(240,218,24)",
              "type": "color"
            },
            "volLength": {
              "default": 20,
              "type": "range",
              "min": 1,
              "max": 200,
              "step": 1
            },
            "atrLength": {
              "default": 20,
              "type": "range",
              "min": 1,
              "max": 200,
              "step": 1
            },
            "useHK": {
              "default": true,
              "type": "checkbox",
              "description": "Use heikinashi as source"
            },
            "useLog": {
              "default": true,
              "type": "checkbox"
            },
            "dynamicMax": {
              "default": true,
              "type": "checkbox"
            },
            "strokeWidth": {
              "default": 0,
              "type": "number",
              "description": "For debug purpose"
            }
          },
          "series": [
            "liquidation-heatmap copy 1",
            "acjp4lwd",
            "lzwewuby",
            "7u77b6mf",
            "r8jhutca",
            "iak6yb3j",
            "ba3j67p5",
            "12eerwe5",
            "okjoqqiw",
            "8pfuy35m",
            "18awcae5",
            "k5g7ml0w",
            "nd0tu918",
            "vql8gu7h",
            "jo1fjihp",
            "ubcrwr1f",
            "d4ta5pw7"
          ],
          "displayName": "Liquidation Heatmap",
          "unsavedChanges": false,
          "lastPreset": null
        },
        "_6fov3tmuy13lvmmv": {
          "id": "_6fov3tmuy13lvmmv",
          "libraryId": "liquidation-heatmap-copy-1",
          "name": "Liquidation Heatmap copy 1",
          "description": "Visualizes potential liquidation levels",
          "script": "leverages = option(default=5|20|100,type=text)\nthreshold = option(default=0,type=range,min=0,max=220,log=true)\nfadeOut = option(default=0,type=range,min=0,max=1,log=true,step=0.001)\nstepScale = option(default=0.5,type=range,min=0,max=2,step=0.01)\nstepValue = option(default=\"\",type=text,placeholder=\"empty = ATR\")\nstrength = option(default=0.25,type=range,min=0,max=10,step=0.01,log=true)\nquote = option(default=null,type=list,options=[null, \"USD\", \"USDT\", \"TUSD\", \"USDC\"],rebuild=true)\nexchange = option(default=null,type=exchange,rebuild=true)\ntype = option(default=perp,type=list,options=[null, \"spot\", \"perp\"],rebuild=true)\nsrc = option(default=\"high/low\",type=list,options=[\"open\", \"high\", \"low\", \"close\",\"hl2\",\"ohl3\",\"ohlc4\",\"hlcc4\",\"high/low\",\"low/high\"])\ncolor0 = option(default=rgba(0,0,0,0),type=color)\ncolor1 = option(default=rgb(63,16,87),type=color)\ncolor2 = option(default=rgb(76,152,134),type=color)\ncolor3 = option(default=rgb(240,218,24),type=color)\nvolLength = option(default=20,type=range,min=1,max=200, step=1)\natrLength = option(default=20,type=range,min=1,max=200, step=1)\nuseHK = option(default=true,type=checkbox,description=\"Use heikinashi as source\")\nuseLog = option(default=true,type=checkbox)\nstrokeWidth = option(default=0,type=number,description=\"For debug purpose\")\n\nif (!liquidityAtPrices) {\n  // init\n\n  lastIndex = null\n  freeSlots = []\n  usedSlots = []\n  boundaries = {}\n  liquidityAtPrices = {}\n  resistances = []\n  supports = []\n  pendingRedraws = []\n  var shortLeverage = options.leverages.toString().split(/[|,]/).map(a => +a)\n  var longLeverage = shortLeverage.map(a => -a)\n  resolvedLeverages = shortLeverage.concat(longLeverage)\n  steps = null\n\n  for (var i = 0; i < series.length; i++) {\n    if (series[i].seriesType() !== 'BrokenArea') {\n      continue\n    }\n\n    // register each available series as a slot \n    freeSlots.push({\n    index: i,\n    redrawAt: 0\n    })\n\n    // bind boundaries reference\n    // boundaries: { [cellId: string]: *bar index* }\n    series[i].setExtensionsBoundaries(boundaries)\n  }\n}\n\n\n// process only on new candle\nif (bar.length === lastIndex) {\n  return\n}\n\nvar customSrc = source(quote=quote,type=type,exchange=exchange)\nvar price = useHK ? avg_heikinashi(customSrc) : avg_ohlc_with_gaps(customSrc)\n\npriceRef = price\n\n// grid size\nif (stepValue) {\n  // absolute\n  steps = stepValue\n} else {\n  // calculated with atr\n  var hl = price.high - price.low\n  var hc = Math.abs(price.high - priceRef[1].close)\n  var lc = Math.abs(price.low - priceRef[1].close)\n  var atr = sma(Math.max(hl, hc, lc), atrLength)\n\n  if (bar.length < atrLength) {\n    return\n  }\n\n  if (!steps) {\n    steps = atr * stepScale\n  }\n}\n\nbuyVolume = source(vbuy, quote=quote,type=type,exchange=exchange)\nsellVolume = source(vsell, quote=quote,type=type,exchange=exchange)\nvol = buyVolume + sellVolume\n\noi = $openinterest\nvar oiDelta = oi.high - oi.low\n\n// since we only run this indi once per bar (for performance)\n// only analyze volume data of the previous bar (vol[1], buyVolume[1], sellVolume[1])\nconst avgBuyVolume = sma(buyVolume[1] || 0, volLength) || 0.0001;\nconst avgSellVolume = sma(sellVolume[1] || 0, volLength) || 0.0001;\n\nvar buyRatio = (buyVolume[1] || 0) / avgBuyVolume;\nvar sellRatio = (sellVolume[1] || 0) / avgSellVolume;\nif (useLog) {\n  buyRatio = Math.log(buyRatio + 1)\n  sellRatio = Math.log(sellRatio + 1)\n}\n\n// custom src\nvar resolvedSrc  = priceRef[1][options.src]\nif (resolvedSrc === undefined) {\n  if (options.src === 'hl2') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low) / 2\n  } else if (options.src === 'ohl3') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low) / 3\n  } else if (options.src === 'ohlc4') {\n    resolvedSrc = (priceRef[1].open + priceRef[1].high + priceRef[1].low + priceRef[1].close) / 4\n  } else if (options.src === 'hlcc4') {\n    resolvedSrc = (priceRef[1].high + priceRef[1].low + priceRef[1].close + priceRef[1].close) / 4\n  }\n}\n\nfor (let i = 0; i < resolvedLeverages.length; i++) {\n  var lev = (resolvedLeverages)[i]\n\n  if (options.src === 'high/low') {\n    resolvedSrc = lev > 0 ? priceRef[1].high : priceRef[1].low\n  } else if (options.src === 'low/high') {\n    resolvedSrc = lev > 0 ? priceRef[1].low : priceRef[1].high\n  }\n\n  // liquidation price (from resolvedSrc + % to leverages[i]) \n  var lp = (resolvedSrc + resolvedSrc * (100 / lev / 100))\n  \n  // rounded lp median (the cell id)\n  var slp = Math.ceil(lp / steps) * steps\n  \n  if (!liquidityAtPrices[slp]) {\n    // register cell\n    var top = slp + steps / 2\n    var bottom = slp - steps / 2\n    liquidityAtPrices[slp] = {\n      strength: 0,\n      count: 0,\n      top: top,\n      bottom: bottom\n    }\n    \n    if (lev > 0) {\n        resistances.push(slp)\n        resistances.sort((a, b) => a - b)\n    } else {\n        supports.push(slp)\n        supports.sort((a, b) => b - a)\n    }\n  }\n  \n  // update cell\n  liquidityAtPrices[slp].count++\n  liquidityAtPrices[slp].strength += lev > 0 ? sellRatio : buyRatio\n  \n  var ratio = Math.min(1, liquidityAtPrices[slp].strength * liquidityAtPrices[slp].count * (options.strength / 100))\n\n  if (ratio < 0.001 || oiDelta < 10) {\n    continue\n  }\n  \n  liquidityAtPrices[slp].color = interpolate(ratio, color0, color1, color2, color3)\n\n  if (liquidityAtPrices[slp].strength > options.threshold) {\n    if (pendingRedraws.indexOf(slp) === -1) {\n      pendingRedraws.push(slp)\n    }\n  }\n}\n\nif (pendingRedraws.length) {\n\n  // round of used slot(s)\n  var slotsToRelease = []\n  for (var i = 0; i < pendingRedraws.length; i++) {\n    var cell = liquidityAtPrices[pendingRedraws[i]]\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\n\n    if (slot) {\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\n      usedSlots.push(usedIndex)\n\n      if (cell.id) {\n        boundaries[cell.id] = bar.length\n      }\n      \n      cell.id = Math.random().toString()\n      renderer.indicators[indicatorId].series[usedIndex] ={\n        id: cell.id,\n        time: time,\n        lowerValue: cell.top,\n        higherValue: cell.bottom,\n        extendRight: true,\n        color: cell.color\n      }\n\n      pendingRedraws.splice(i--, 1)\n      slotsToRelease.push(usedIndex)\n    }\n  }\n  for (let i = 0; i < slotsToRelease.length; i++) {\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\n    \n    freeSlots.push({\n      index: plotIndexToFree,\n      redrawAt: bar.length + 1\n    })\n  }\n}\n\nfor (let i = 0; i < supports.length; i++) {\n  if (\n   price.low <= supports[i] || liquidityAtPrices[supports[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[supports[i]].id] = bar.length\n    delete liquidityAtPrices[supports[i]]\n    supports.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[supports[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\nfor (let i = 0; i < resistances.length; i++) {\n  if (\n   price.high >= resistances[i] || liquidityAtPrices[resistances[i]].count <= 0\n  ) {\n    boundaries[liquidityAtPrices[resistances[i]].id] = bar.length\n    delete liquidityAtPrices[resistances[i]]\n    resistances.splice(i--, 1)\n  } else {\n    if (fadeOut) {\n      liquidityAtPrices[resistances[i]].count -= fadeOut\n    } else {\n      break;\n    }\n  }\n}\n\n// set reference to bar index : avoid process next tick\nlastIndex = bar.length\n\n// define available series\nif (renderer.indicators[indicatorId].series[0]) {\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[1]) {\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[2]) {\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[3]) {\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[4]) {\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[5]) {\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[6]) {\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[7]) {\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[8]) {\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[9]) {\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[10]) {\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[11]) {\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[12]) {\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[13]) {\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[14]) {\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[15]) {\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}\nif (renderer.indicators[indicatorId].series[16]) {\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\n}",
          "createdAt": 1713246424998,
          "updatedAt": 1713335066518,
          "options": {
            "priceScaleId": "right",
            "leverages": "5|20|100",
            "threshold": 0,
            "fadeOut": 0,
            "stepScale": 0.5,
            "stepValue": "",
            "strength": 0.25,
            "quote": 0,
            "exchange": 0,
            "type": "perp",
            "src": "high/low",
            "volLength": 20,
            "atrLength": 20,
            "useHK": true,
            "useLog": true,
            "strokeWidth": 0,
            "visible": false,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            }
          },
          "optionsDefinitions": {
            "leverages": {
              "default": "5|20|100",
              "type": "text"
            },
            "threshold": {
              "default": 0,
              "type": "range",
              "min": 0,
              "max": 220,
              "log": true
            },
            "fadeOut": {
              "default": 0,
              "type": "range",
              "min": 0,
              "max": 1,
              "log": true,
              "step": 0.001
            },
            "stepScale": {
              "default": 0.5,
              "type": "range",
              "min": 0,
              "max": 2,
              "step": 0.01
            },
            "stepValue": {
              "default": "",
              "type": "text",
              "placeholder": "empty = ATR"
            },
            "strength": {
              "default": 0.25,
              "type": "range",
              "min": 0,
              "max": 10,
              "step": 0.01,
              "log": true
            },
            "quote": {
              "default": 0,
              "type": "list",
              "options": [
                null,
                "USD",
                "USDT",
                "TUSD",
                "USDC"
              ],
              "rebuild": true
            },
            "exchange": {
              "default": 0,
              "type": "exchange",
              "rebuild": true
            },
            "type": {
              "default": "perp",
              "type": "list",
              "options": [
                null,
                "spot",
                "perp"
              ],
              "rebuild": true
            },
            "src": {
              "default": "high/low",
              "type": "list",
              "options": [
                "open",
                "high",
                "low",
                "close",
                "hl2",
                "ohl3",
                "ohlc4",
                "hlcc4",
                "high/low",
                "low/high"
              ]
            },
            "color0": {
              "default": "rgba(0,0,0,0)",
              "type": "color"
            },
            "color1": {
              "default": "rgb(63,16,87)",
              "type": "color"
            },
            "color2": {
              "default": "rgb(76,152,134)",
              "type": "color"
            },
            "color3": {
              "default": "rgb(240,218,24)",
              "type": "color"
            },
            "volLength": {
              "default": 20,
              "type": "range",
              "min": 1,
              "max": 200,
              "step": 1
            },
            "atrLength": {
              "default": 20,
              "type": "range",
              "min": 1,
              "max": 200,
              "step": 1
            },
            "useHK": {
              "default": true,
              "type": "checkbox",
              "description": "Use heikinashi as source"
            },
            "useLog": {
              "default": true,
              "type": "checkbox"
            },
            "strokeWidth": {
              "default": 0,
              "type": "number",
              "description": "For debug purpose"
            }
          },
          "series": [
            "liquidation-heatmap-copy-1",
            "xrzejb1b",
            "luyv89qc",
            "9t8618lf",
            "lq62vvf6",
            "pzduodoq",
            "dc5wgvi4",
            "vhehdn5e",
            "vmf6je7n",
            "ryav5ezn",
            "ad4qu0ho",
            "vckkxn9o",
            "w0r4b9hz",
            "uf1t6xbj",
            "t1o1qp87",
            "osjlodzg",
            "3zulxw73"
          ],
          "displayName": "Liquidation Heatmap copy 1",
          "unsavedChanges": false
        },
        "_tl0sezw2my46cdj3": {
          "id": "_tl0sezw2my46cdj3",
          "libraryId": "top-bands-spots-copy-1",
          "name": "Top Levels Spot/Perp",
          "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\nminVolume = option(default=50,type=range,min=0,max=1000)\r\nmaxVolume = option(default=500,type=range,min=0,max=5000)\r\ndynamicMax = option(default=true,type=checkbox)\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    topBandAtPrice = {}\r\n\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n\r\n    colorLevel0 = options.colorLevel0 \r\n    colorLevel1 = options.colorLevel1\r\n    colorLevel = options.colorLevel\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push({\r\n        index: i,\r\n        redrawAt: 0 \r\n      })\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\n/*if (bar.length < lastIndex) {\r\n  return\r\n}*/\r\n\r\n\r\n\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\n  if( new Date().getTime() > (renderer.timestamp + renderer.timeframe)*1000 ){\r\n    return\r\n  } \r\n\r\nif( dynamicMax ){\r\n  levels.bids.sort( (a, b) => a[0] - b[0] )\r\n  levels.asks.sort( (a, b) => a[0] - b[0] )\r\n  maxVolumeDetected = levels.bids[0][1] > levels.asks[0][1] ? levels.bids[0][1] : levels.asks[0][1];\r\n}\r\n\r\nlevels.bids.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n\r\n\r\n  if( level[1] < minVolume ){\r\n    return;\r\n  }\r\n\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] /(dynamicMax ? maxVolumeDetected : maxVolume), colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nlevels.asks.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nif (pendingRedraws.length) {\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\r\n\r\n    if (slot) {\r\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\r\n      usedSlots.push(usedIndex)\r\n\r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time + renderer.timeframe * 10,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n      slotsToRelease.push(usedIndex)\r\n    }\r\n\r\n    delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      redrawAt: bar.length + 1\r\n    })\r\n  }\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
          "createdAt": 1713304521424,
          "updatedAt": 1713313893105,
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false,
            "colorLevels": "rgb(255,255,255)",
            "colorLevel1": "rgba(255,235,59,0.73)",
            "colorLevel0": "rgba(156,39,176,0.73)",
            "colorLevel": "rgba(120,123,134,0.83)",
            "level0": 700,
            "level1": 400,
            "maxVolume": 400,
            "minVolume": 0,
            "startOpacity": 0.4,
            "togglePerp": false,
            "bandSize": 20,
            "lastValueVisible": false,
            "color": "rgb(76,175,80)",
            "limitPercent": 6,
            "priceLineVisible": false,
            "strokeWidth": 0,
            "strokeColor": "rgb(49,121,245)",
            "dynamicMax": false
          },
          "optionsDefinitions": {
            "strokeWidth": {
              "default": 0,
              "type": "number",
              "description": "For debug purpose"
            },
            "minVolume": {
              "default": 50,
              "type": "range",
              "min": 0,
              "max": 1000
            },
            "maxVolume": {
              "default": 500,
              "type": "range",
              "min": 0,
              "max": 5000
            },
            "dynamicMax": {
              "default": true,
              "type": "checkbox"
            }
          },
          "displayName": "Top Levels Spot/Perp",
          "series": [
            "top-bands-spots-copy-1",
            "up8vs0ce",
            "c90glg3o",
            "tpabocdp",
            "stdkirs3",
            "clvaxgiq",
            "wo12j7af",
            "gd2sdmld",
            "3ve5q5i5",
            "vew0u6t0",
            "n8isyk0w",
            "opwbcgfq",
            "7ropcpja",
            "fjjlce71",
            "4gpnnkne",
            "p2epm216",
            "8u9o1ti5"
          ],
          "unsavedChanges": false
        },
        "_0mg4vqeobgu9ep1h": {
          "id": "_0mg4vqeobgu9ep1h",
          "name": "Top Bands Spots copy 2",
          "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    topBandAtPrice = {}\r\n\r\n    // runs only once\r\n    pendingMarkers = [] \r\n\r\n    togglePerp = options.togglePerp || false\r\n    \r\n    moveTo = options.togglePerp ? 10 : -10\r\n    bandSize = options.bandSize || 15\r\n\r\n    maxVolume = options.maxVolume || (togglePerp ? 4000 : 1500)\r\n    minVolume = options.minVolume || (togglePerp ? 500 : 200)\r\n\r\n    level0 = options.level0 || (togglePerp ? 2000 : 800)\r\n    level1 = options.level1 || (togglePerp ? 1000 : 400)\r\n\r\n    startOpacity = options.startOpacity || 0.1\r\n\r\n    colorLevel0 = options.colorLevel0 \r\n    colorLevel1 = options.colorLevel1\r\n    colorLevel = options.colorLevel\r\n\r\n    /*colorLevel0 = options.colorLevel0.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel1 = options.colorLevel1.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n    colorLevel = options.colorLevel.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n\r\n    colorOpacity0 = colorLevel0.pop()\r\n    colorOpacity1 = colorLevel1.pop()\r\n    colorOpacity2 = colorLevel.pop()*/\r\n\r\n    limitPercent = (options.limitPercent || 100) / 100\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push({\r\n        index: i,\r\n        redrawAt: 0 \r\n      })\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\nif (bar.length < lastIndex) {\r\n  return\r\n}\r\n\r\nif( new Date().getTime() > (renderer.timestamp + renderer.timeframe)*1000 ){\r\n  return\r\n} \r\n\r\nvar topLimit = $price.close + $price.close * limitPercent\r\nvar bottomLimit = $price.close - $price.close * limitPercent\r\n\r\nvar levels = togglePerp ? ORDERBOOK:AGGRPERP-BTCUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\nif( !levels ){\r\n  return\r\n}\r\n// avoid too many changes\r\n//levels.bids.sort( (a, b) => a[0] - b[0] )\r\n//levels.asks.sort( (a, b) => a[0] - b[0] )\r\n\r\nlevels.bids.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nlevels.asks.forEach( (level) => {\r\n  var resolvedSrc = level[0] // price already rounded\r\n\r\n  if (!topBandAtPrice[resolvedSrc]) {\r\n    // register cell\r\n    var top = resolvedSrc + bandSize\r\n    var bottom = resolvedSrc\r\n\r\n    topBandAtPrice[resolvedSrc] = {\r\n      strength: 0,\r\n      count: 0,\r\n      top: top,\r\n      bottom: bottom\r\n    }\r\n    \r\n  }\r\n\r\n  topBandAtPrice[resolvedSrc].color =  interpolate(level[1] / maxVolume, colorLevel, colorLevel1, colorLevel0);\r\n  //console.log(topBandAtPrice[resolvedSrc].color);\r\n\r\n   if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n\r\n})\r\n\r\nif (pendingRedraws.length) {\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    var slot = freeSlots.find(slot => slot.redrawAt < bar.length)\r\n\r\n    if (slot) {\r\n      var usedIndex = freeSlots.splice(freeSlots.indexOf(slot), 1)[0].index\r\n      usedSlots.push(usedIndex)\r\n\r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n      slotsToRelease.push(usedIndex)\r\n    }\r\n\r\n    delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(slotsToRelease[i]), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      redrawAt: bar.length + 1\r\n    })\r\n  }\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false,
            "colorLevels": "rgb(255,255,255)",
            "colorLevel1": "rgba(255,255,255,0.94)",
            "colorLevel0": "rgba(156,39,176,0.93)",
            "colorLevel": "rgba(120,123,134,0.83)",
            "level0": 700,
            "level1": 400,
            "maxVolume": 500,
            "minVolume": 200,
            "startOpacity": 0.4,
            "togglePerp": false,
            "bandSize": 20,
            "lastValueVisible": false,
            "color": "rgb(76,175,80)",
            "limitPercent": 6,
            "priceLineVisible": false,
            "strokeWidth": 0,
            "strokeColor": "rgb(49,121,245)"
          },
          "optionsDefinitions": {
            "strokeWidth": {
              "default": 0,
              "type": "number",
              "description": "For debug purpose"
            }
          },
          "series": [
            "_0mg4vqeobgu9ep1h",
            "9ngb1uxm",
            "5fe4xo6p",
            "whknog24",
            "6r9ac4iy",
            "56l3avgt",
            "179dzp6z",
            "fa7fwse4",
            "mdc88eir",
            "ts7d45dw",
            "r42v02zm",
            "ga38iazi",
            "k5zxwx3p",
            "00yeko42",
            "gp4kks4h",
            "wozdovnt",
            "32lc0p5g"
          ],
          "displayName": "Top Bands Spots copy 2"
        },
        "_cj0l7ltnxfoj1neg": {
          "id": "_cj0l7ltnxfoj1neg",
          "libraryId": "top-levels",
          "name": "Top Levels ",
          "script": "strokeWidth = option(default=0,type=number,description=\"For debug purpose\")\r\nminVolumeSpot = option(default=50,type=range,min=0,max=1000)\r\nmaxVolumeSpot = option(default=500,type=range,min=0,max=5000)\r\nminVolumePerp = option(default=50,type=range,min=0,max=1000)\r\nmaxVolumePerp = option(default=500,type=range,min=0,max=5000)\r\ndynamicMax = option(default=true,type=checkbox)\r\nuseSameColor = option(default=true,type=checkbox)\r\napplyAlpha = option(default=false,type=checkbox)\r\nuseSingleColor = option(default=false,type=checkbox)\r\neth = option(default=false,type=checkbox)\r\nalphaBase = option(default=0.2,type=range,min=0,max=1,step=0.1)\r\ncolor0 = option(default=rgba(0,0,0,0),type=color)\r\ncolor1 = option(default=rgb(63,16,87),type=color)\r\ncolor2 = option(default=rgb(76,152,134),type=color)\r\ncolor3 = option(default=rgb(240,218,24),type=color)\r\n\r\ncolorPerp0 = option(default=rgba(0,0,0,0),type=color)\r\ncolorPerp1 = option(default=rgb(63,16,87),type=color)\r\ncolorPerp2 = option(default=rgb(76,152,134),type=color)\r\ncolorPerp3 = option(default=rgb(240,218,24),type=color)\r\ncolorBoth = option(default=rgb(240,218,24),type=color)\r\nstrengthSpot = option(default=1,type=range,min=0,max=1,step=0.01)\r\nstrengthPerp = option(default=1,type=range,min=0,max=1,step=0.01)\r\n\r\nfunction interpolateAlpha(ratio, c ){\r\n  var startOpacity = alphaBase\r\n  var alpha = startOpacity + (1 - startOpacity) * ratio\r\n  var alphaRounded = Math.round(alpha * 100) / 100 \r\n  var colorBase = c.match(/\\(([\\d.]+),([\\d.]+),([\\d.]+),?([\\d.]+)?\\)$/).slice(1,5).map(a => +a)\r\n  var alpha = colorBase.pop()\r\n  var finalColor = 'rgba(' + colorBase.join(',') + ',' + alphaRounded + ')'\r\n  return finalColor\r\n}\r\n/*if( useSameColor ){  \r\n  colorPerp0 = color0\r\n  colorPerp1 = color1\r\n  colorPerp2 = color2\r\n  colorPerp3 = color3\r\n}*/\r\n\r\nif (!pendingMarkers) {\r\n    freeSlots = []\r\n    usedSlots = []\r\n    boundaries = {}\r\n    pendingRedraws = []\r\n    \r\n    // runs only once\r\n    pendingMarkers = [] \r\n    \r\n    bandSize = options.bandSize || 15\r\n\r\n    for (var i = 0; i < series.length; i++) {\r\n      if (series[i].seriesType() !== 'BrokenArea') {\r\n        continue\r\n      }\r\n\r\n      // register each available series as a slot \r\n      freeSlots.push(i)\r\n\r\n      // bind boundaries reference\r\n      // boundaries: { [cellId: string]: *bar index* }\r\n      series[i].setExtensionsBoundaries(boundaries)\r\n    }\r\n}\r\n\r\n// Don't presist\r\nvar topBandAtPrice = {};\r\n\r\n// process only on new candle\r\n/*if (bar.length === lastIndex) {\r\n  return\r\n}*/\r\n\r\nif (bar.length < lastIndex) {\r\n  //console.log('not last index')\r\n  return\r\n}\r\n\r\n// avoid too many changes\r\nif( new Date().getTime() >= (renderer.timestamp + renderer.timeframe)*1000 ){\r\n  /*for (var i = 0; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n     renderer.indicators[indicatorId].series[i] ={\r\n        id: Math.random().toString(),\r\n        time: renderer.timestamp,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n  }*/\r\n  //console.log('not last candle', renderer.timestamp)\r\n  return\r\n} \r\n\r\n/*function getRandomNumber() {\r\n  return Math.floor(Math.random() * (4000 - 500 + 1)) + 500;\r\n}*/\r\n//var perpLevels = {bids: [[$price.close - getRandomNumber(), 5000]], asks: [[$price.close + getRandomNumber(), 5000]]}\r\n//var spotLevels = {bids: [[$price.close - getRandomNumber(), 1000]], asks: [[$price.close + getRandomNumber(), 5000]]}\r\n\r\nvar perpLevels = eth ? ORDERBOOK:AGGRPERP-ETHUSD.zlevels  : ORDERBOOK:AGGRPERP-BTCUSD.zlevels \r\nvar spotLevels = eth ? ORDERBOOK:AGGRPERP-ETHUSD.zlevels  : ORDERBOOK:AGGRSPOT-BTCUSD.zlevels\r\n\r\n\r\nif( !perpLevels && !spotLevels ){\r\n  return\r\n}\r\n\r\n/*if( dynamicMax ){\r\n  levels.bids.sort( (a, b) => a[0] - b[0] )\r\n  levels.asks.sort( (a, b) => a[0] - b[0] )\r\n  maxVolumeDetected = levels.bids[0][1] > levels.asks[0][1] ? levels.bids[0][1] : levels.asks[0][1];\r\n}*/\r\n\r\n// 1.5 seconds before end of candle\r\nvar isAboutToEnd = new Date().getTime() >= (renderer.timestamp + renderer.timeframe)*1000 - 1800\r\n\r\nif( !isAboutToEnd ){\r\n  spotLevels.bids.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumeSpot ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumeSpot)\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio * strengthSpot)\r\n\r\n    if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = color3\r\n    }else{ \r\n      topBandAtPrice[resolvedSrc].color =  interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color =  interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color);\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  spotLevels.asks.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumeSpot ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumeSpot)\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthSpot)\r\n\r\n    if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = color3\r\n    }else{ \r\n      topBandAtPrice[resolvedSrc].color =  interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color =  interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color);\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  perpLevels.bids.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumePerp ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumePerp)\r\n    var hasSpotLevel = topBandAtPrice[resolvedSrc].strength > 0.3\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthPerp)\r\n\r\n    if( hasSpotLevel ){\r\n      topBandAtPrice[resolvedSrc].color = colorBoth\r\n    } else if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = colorPerp3\r\n    } else if( useSameColor ){\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }else{\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, colorPerp0, colorPerp1, colorPerp2, colorPerp3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color = interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color );\r\n    }\r\n\r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n\r\n  perpLevels.asks.forEach( (level) => {\r\n    var resolvedSrc = level[0] // price already rounded\r\n\r\n    if (!topBandAtPrice[resolvedSrc]) {\r\n      // register cell\r\n      var top = resolvedSrc + bandSize\r\n      var bottom = resolvedSrc\r\n\r\n      topBandAtPrice[resolvedSrc] = {\r\n        strength: 0,\r\n        count: 0,\r\n        top: top,\r\n        bottom: bottom\r\n      }\r\n    }\r\n\r\n    if( level[1] < minVolumePerp ){\r\n      return;\r\n    }\r\n\r\n    var ratio = level[1] /(dynamicMax ? maxVolumeDetected : maxVolumePerp)\r\n    var hasSpotLevel = topBandAtPrice[resolvedSrc].strength > 0.3\r\n    topBandAtPrice[resolvedSrc].strength += Math.min(1, ratio*strengthPerp)\r\n\r\n    if( hasSpotLevel ){\r\n      topBandAtPrice[resolvedSrc].color = colorBoth\r\n    } else if( useSingleColor ){\r\n      topBandAtPrice[resolvedSrc].color = colorPerp3\r\n    } else if( useSameColor ){\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, color0, color1, color2, color3);\r\n    }else{\r\n      topBandAtPrice[resolvedSrc].color = interpolate(topBandAtPrice[resolvedSrc].strength, colorPerp0, colorPerp1, colorPerp2, colorPerp3);\r\n    }\r\n    if( applyAlpha ){\r\n      topBandAtPrice[resolvedSrc].color = interpolateAlpha(topBandAtPrice[resolvedSrc].strength, topBandAtPrice[resolvedSrc].color );\r\n    }\r\n    \r\n    if (pendingRedraws.indexOf(resolvedSrc) === -1) {\r\n      pendingRedraws.push(resolvedSrc)\r\n    }\r\n  })\r\n}else{\r\n  console.log('Anout to expire')\r\n  for (var i = 0; i < series.length; i++) {\r\n    if (series[i].seriesType() !== 'BrokenArea') {\r\n      continue\r\n    }\r\n\r\n     renderer.indicators[indicatorId].series[i] ={\r\n        id: Math.random().toString(),\r\n        time: time + renderer.timeframe,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n  }\r\n}\r\n\r\nif (pendingRedraws.length) {\r\n  \r\n  // free all the slots that won't be redrawn\r\n  for (var i = 0; i < usedSlots.length; i++) {\r\n\r\n    var level = usedSlots[i][1]\r\n\r\n    // do we have a level to redraw?\r\n    var exist = pendingRedraws.includes(level)\r\n    if( !exist ){\r\n      var usedIndex = usedSlots[i][0]\r\n\r\n      freeSlots.push(usedIndex)\r\n      usedSlots.splice(i--, 1)\r\n      renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: Math.random().toString(),\r\n        time: time + renderer.timeframe,\r\n        lowerValue: 0,\r\n        higherValue: 0,\r\n        extendRight: false\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  // round of used slot(s)\r\n  var slotsToRelease = []\r\n  for (var i = 0; i < pendingRedraws.length; i++) {\r\n    var cell = topBandAtPrice[pendingRedraws[i]]\r\n    // find a brokenarea index to use\r\n    // var slot = freeSlots.find(slot => slot.redrawAt <= bar.length)\r\n    // find a brokenarea already use to draw same level or first one\r\n    var reuse = usedSlots.find(slot => slot[1] === pendingRedraws[i])\r\n    \r\n    var useIndex = (reuse && reuse[0]) || (freeSlots.length && freeSlots[0]) \r\n\r\n    // if we have one\r\n    if (useIndex >= 0) {\r\n      // removed it from freeSlots\r\n      freeSlots.splice(freeSlots.indexOf(useIndex), 1)\r\n      // put it in usedSlots\r\n      !reuse && usedSlots.push([useIndex, pendingRedraws[i]])\r\n      \r\n      if (cell.id) {\r\n        boundaries[cell.id] = bar.length\r\n      }\r\n      \r\n      cell.id = Math.random().toString()\r\n      /*renderer.indicators[indicatorId].series[usedIndex] ={\r\n        id: cell.id,\r\n        time: time - renderer.timeframe,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.top,\r\n        extendRight: false,\r\n        color: cell.color\r\n      }*/\r\n      renderer.indicators[indicatorId].series[useIndex] ={\r\n        id: cell.id,\r\n        time: time + renderer.timeframe,\r\n        lowerValue: cell.top,\r\n        higherValue: cell.bottom,\r\n        extendRight: true,\r\n        color: cell.color\r\n      }\r\n\r\n      pendingRedraws.splice(i--, 1)\r\n\r\n      //slotsToRelease.push([usedIndex, pendingRedraws[i]])\r\n    }else{\r\n      console.log('No more slots')\r\n    }\r\n\r\n    //delete topBandAtPrice[pendingRedraws[i]]\r\n  }\r\n  /*for (let i = 0; i < slotsToRelease.length; i++) {\r\n    var ind = slotsToRelease[i][0]\r\n    var level = slotsToRelease[i][1]\r\n    var plotIndexToFree = usedSlots.splice(usedSlots.indexOf(ind), 1)[0]\r\n    \r\n    freeSlots.push({\r\n      index: plotIndexToFree,\r\n      level: level\r\n    })\r\n  }*/\r\n \r\n}\r\n\r\n// set reference to bar index : avoid process next //tick\r\nlastIndex = bar.length\r\n\r\n// define available series\r\nif (renderer.indicators[indicatorId].series[0]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[1]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[2]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[3]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[4]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[5]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[6]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[6] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[7]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[7] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[8]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[8] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[9]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[9] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[10]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[10] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[11]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[11] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[12]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[12] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[13]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[13] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[14]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[14] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[15]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[15] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[16]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[16] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[17]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[17] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[18]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[18] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}\r\nif (renderer.indicators[indicatorId].series[19]) {\r\n  brokenarea(renderer.indicators[indicatorId].series[19] || { time: time }, strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n}",
          "createdAt": 1713314961958,
          "updatedAt": 1713486743951,
          "options": {
            "priceScaleId": "right",
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            },
            "visible": false,
            "colorLevels": "rgb(255,255,255)",
            "colorLevel1": "rgba(255,235,59,0.73)",
            "colorLevel0": "rgba(156,39,176,0.73)",
            "colorLevel": "rgba(120,123,134,0.83)",
            "level0": 700,
            "level1": 400,
            "maxVolume": 400,
            "minVolume": 0,
            "startOpacity": 0.4,
            "togglePerp": false,
            "bandSize": 40,
            "lastValueVisible": false,
            "color": "rgb(76,175,80)",
            "limitPercent": 6,
            "priceLineVisible": false,
            "strokeWidth": 0,
            "strokeColor": "rgb(49,121,245)",
            "dynamicMax": false,
            "minVolumeSpot": 100,
            "maxVolumeSpot": 500,
            "minVolumePerp": 200,
            "maxVolumePerp": 1500,
            "eth": false,
            "color1": "rgba(255,255,255,0.55)",
            "strengthSpot": 1,
            "strengthPerp": 1,
            "useSameColor": false,
            "colorPerp0": "rgba(42,46,57,0.08)",
            "colorPerp1": "rgba(255,255,255,0.55)",
            "colorPerp2": "rgb(255,152,0)",
            "colorPerp3": "rgb(41,98,255)",
            "colorBoth": "rgb(178,40,51)",
            "color2": "rgb(56,142,60)",
            "color3": "rgb(255,235,59)",
            "useAlpha": true,
            "applyAlpha": true,
            "useSingleColor": true,
            "alphaBase": 0.1,
            "color0": "rgba(42,46,57,0.08)"
          },
          "optionsDefinitions": {
            "strokeWidth": {
              "default": 0,
              "type": "number",
              "description": "For debug purpose"
            },
            "minVolumeSpot": {
              "default": 50,
              "type": "range",
              "min": 0,
              "max": 1000
            },
            "maxVolumeSpot": {
              "default": 500,
              "type": "range",
              "min": 0,
              "max": 5000
            },
            "minVolumePerp": {
              "default": 50,
              "type": "range",
              "min": 0,
              "max": 1000
            },
            "maxVolumePerp": {
              "default": 500,
              "type": "range",
              "min": 0,
              "max": 5000
            },
            "dynamicMax": {
              "default": true,
              "type": "checkbox"
            },
            "useSameColor": {
              "default": true,
              "type": "checkbox"
            },
            "applyAlpha": {
              "default": 0,
              "type": "checkbox"
            },
            "useSingleColor": {
              "default": 0,
              "type": "checkbox"
            },
            "eth": {
              "default": 0,
              "type": "checkbox"
            },
            "alphaBase": {
              "default": 0.2,
              "type": "range",
              "min": 0,
              "max": 1,
              "step": 0.1
            },
            "color0": {
              "default": "rgba(0,0,0,0)",
              "type": "color"
            },
            "color1": {
              "default": "rgb(63,16,87)",
              "type": "color"
            },
            "color2": {
              "default": "rgb(76,152,134)",
              "type": "color"
            },
            "color3": {
              "default": "rgb(240,218,24)",
              "type": "color"
            },
            "colorPerp0": {
              "default": "rgba(0,0,0,0)",
              "type": "color"
            },
            "colorPerp1": {
              "default": "rgb(63,16,87)",
              "type": "color"
            },
            "colorPerp2": {
              "default": "rgb(76,152,134)",
              "type": "color"
            },
            "colorPerp3": {
              "default": "rgb(240,218,24)",
              "type": "color"
            },
            "colorBoth": {
              "default": "rgb(240,218,24)",
              "type": "color"
            },
            "strengthSpot": {
              "default": 1,
              "type": "range",
              "min": 0,
              "max": 1,
              "step": 0.01
            },
            "strengthPerp": {
              "default": 1,
              "type": "range",
              "min": 0,
              "max": 1,
              "step": 0.01
            }
          },
          "displayName": "Top Levels ",
          "series": [
            "top-levels",
            "yskpvjgq",
            "npb8mya7",
            "5na1f92g",
            "2kw8ghh6",
            "y3d0w4mn",
            "o8danqot",
            "nak3ge8n",
            "n55thxdh",
            "emm0mgmj",
            "dvasyhbx",
            "3197nrqy",
            "63bkfnxi",
            "h5zkx2u0",
            "yezuuvji",
            "mmxt3t56",
            "k8hvwzwh",
            "avuuhxao",
            "cs2wf5ln",
            "6ipam413"
          ],
          "unsavedChanges": false
        },
        "_o80kom7k7pku24i7": {
          "id": "_o80kom7k7pku24i7",
          "libraryId": "my-levels",
          "name": "my levels",
          "script": "if( !fetchOnce ){\r\n  lastIndex = null\r\n  fetchOnce = 1\r\n\r\n  if (bar.length === 1 && lastIndex === null ) {\r\n    myFetch = globalThis.fetch.bind(globalThis) \r\n    myFetch(\"http:\\/\\/localhost:3001/api/trader/state\")\r\n      .then(res => res.json())\r\n      .then(data => {\r\n        console.log('store', data)\r\n        localStorage.lastData = JSON.stringify(data)  \r\n      })\r\n  }\r\n\r\n}\r\n\r\n\r\n// process only first candle\r\n// bar.length at the start of each chunk\r\n/*if (bar.length !== 1 ) {\r\n   return\r\n}*/\r\n\r\nif (bar.length < lastIndex) {\r\n  return\r\n}\r\n\r\n// avoid too many changes\r\nif( new Date().getTime() >= (renderer.timestamp + renderer.timeframe)*1000 ){\r\n  return\r\n} \r\n\r\n// set reference to bar index : avoid process next tick\r\nlastIndex = bar.length\r\n\r\nlastData = JSON.parse(localStorage?.lastData || '{}')\r\nif( lastData ){\r\n  for( var i = 0; i < lastData.buyLevels.length; i++ ){\r\n    renderer.indicators[indicatorId].series[i] ={\r\n      id:  Math.random().toString(),\r\n      time: time,\r\n      lowerValue: lastData.buyLevels[i].bottom,\r\n      higherValue: lastData.buyLevels[i].top,\r\n      extendRight: true,\r\n      color: options.buyColor\r\n    }\r\n  }\r\n  for( var i = 0; i < lastData.sellLevels.length; i++ ){\r\n    renderer.indicators[indicatorId].series[2+i] ={\r\n      id:  Math.random().toString(),\r\n      time: time,\r\n      lowerValue: lastData.sellLevels[i].bottom,\r\n      higherValue: lastData.sellLevels[i].top,\r\n      extendRight: true,\r\n      color: options.sellColor\r\n    }\r\n  }\r\n\r\n}\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[0] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[1] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[2] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[3] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[4] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)\r\n\r\nbrokenarea(renderer.indicators[indicatorId].series[5] || { time: time }, \r\n    strokeColor=options.strokeColor, strokeWidth=options.strokeWidth)",
          "createdAt": 1723763191607,
          "updatedAt": 1723837781538,
          "options": {
            "priceScaleId": "right",
            "stepValue": "",
            "urlValue": "\"http:\r\nif( !drawOnce ){\r\n  \r\n  drawOnce = 1\r\n\r\n  test = globalThis.fetch.bind(globalThis) \r\n  test(options.urlValue).then(res => {\r\n    console.log(res) \r\n  }) \r\n  bottom = 50000\r\n  top = 53000\r\n}\r\n\r\n\r\nline(bottom)\r\nline(top",
            "strokeWidth": 1,
            "color": "rgba(76,175,80,0.28)",
            "visible": true,
            "scaleMargins": {
              "top": 0.35,
              "bottom": 0.16
            }
          },
          "optionsDefinitions": {},
          "series": [
            "my-levels",
            "f930jfe5",
            "eut8nxi3",
            "ehiz3atu",
            "ylc9qj0s",
            "2ygvzuc9"
          ],
          "displayName": "my levels",
          "unsavedChanges": false
        }
      },
      "indicatorOrder": [
        "_my4zvk49em6mh062",
        "price",
        "_cj0l7ltnxfoj1neg",
        "_7o282jzm9vulptiq",
        "overlays-all",
        "orderbook-0-1-spot",
        "liquidations",
        "orderbook-0-1-perp",
        "perpvscoinbase",
        "orderbook-perp",
        "large-liquidations",
        "spotvsperp",
        "orderbook-spot",
        "trades",
        "ob-speed",
        "averages",
        "_bc6lfhgxb0wc36l9",
        "bollinger-bands",
        "_f8i6stuml3q7zwkc",
        "_pngsl31b0gpvtuas",
        "top-bands-perps",
        "top-bands-spots",
        "alerts",
        "_oh4jdeuqr3sfb21e",
        "volume",
        "_6fov3tmuy13lvmmv",
        "_0mg4vqeobgu9ep1h",
        "_tl0sezw2my46cdj3",
        "_o80kom7k7pku24i7"
      ],
      "priceScales": {
        "right": {
          "scaleMargins": {
            "top": 0.35,
            "bottom": 0.16
          },
          "indicators": [
            "Price"
          ],
          "priceFormat": {
            "precision": 1,
            "minMove": 0.1
          }
        },
        "cvd": {
          "scaleMargins": {
            "top": 0.39,
            "bottom": 0.48
          },
          "indicators": [
            "CVD"
          ]
        },
        "volume_liquidations": {
          "scaleMargins": {
            "top": 0,
            "bottom": 0.96
          },
          "indicators": [
            "Liquidations"
          ]
        },
        "volume": {
          "scaleMargins": {
            "top": 0.88,
            "bottom": 0
          },
          "indicators": [
            "Volume"
          ]
        },
        "orderbook-0-1-spot": {
          "scaleMargins": {
            "top": 0.71,
            "bottom": 0.25
          },
          "indicators": [
            "Orderbook 0-1% spot"
          ],
          "priceFormat": {
            "precision": 1,
            "minMove": 0.1
          }
        },
        "orderbook-0-1-perp": {
          "scaleMargins": {
            "top": 0.86,
            "bottom": 0.1
          },
          "indicators": [
            "Orderbook 0-1% perp"
          ],
          "priceFormat": {
            "precision": 1,
            "minMove": 0.1
          }
        },
        "orderbook-spot": {
          "scaleMargins": {
            "top": 0.77,
            "bottom": 0.15
          },
          "indicators": [
            "Orderbook spot"
          ],
          "priceFormat": {
            "precision": 1,
            "minMove": 0.1
          }
        },
        "orderbook-perp": {
          "scaleMargins": {
            "top": 0.91,
            "bottom": 0
          },
          "indicators": [
            "Orderbook Perp"
          ]
        },
        "left": {
          "scaleMargins": {
            "top": 0.59,
            "bottom": 0.28
          }
        },
        "test": {
          "scaleMargins": {
            "top": 0.1,
            "bottom": 0.2
          }
        },
        "bids-asks-total": {
          "scaleMargins": {
            "top": 0.09,
            "bottom": 0.82
          },
          "indicators": [
            "bids asks total"
          ]
        },
        "cvd-btc-spot-cb": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD Coinbase"
          ]
        },
        "cvd-binance-perp-futures": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD Binance Perps"
          ]
        },
        "cvd-binance-spot": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD Binance Spot "
          ]
        },
        "perps-premiuum-simple": {
          "scaleMargins": {
            "top": 0.2,
            "bottom": 0.77
          },
          "indicators": [
            "perps premiuum simple"
          ]
        },
        "perpvscoinbase": {
          "scaleMargins": {
            "top": 0.23,
            "bottom": 0.74
          },
          "indicators": [
            "perpvscoinbase"
          ]
        },
        "spotvsperp": {
          "scaleMargins": {
            "top": 0.2,
            "bottom": 0.77
          },
          "indicators": [
            "SpotVSPerp"
          ]
        },
        "trades": {
          "scaleMargins": {
            "top": 0.67,
            "bottom": 0.29
          },
          "indicators": [
            "trades"
          ]
        },
        "obv": {
          "scaleMargins": {
            "top": 0.14,
            "bottom": 0.21
          }
        },
        "obv-copy-1": {
          "scaleMargins": {
            "top": 0.14,
            "bottom": 0.21
          }
        },
        "ob-speed": {
          "scaleMargins": {
            "top": 0.62,
            "bottom": 0.33
          },
          "indicators": [
            "OB speed"
          ]
        },
        "cvdperp": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD (BTC PERP)"
          ]
        },
        "cvdspot": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD (BTC SPOT)"
          ]
        },
        "_v9ix9ggm0looumtf": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD Binance"
          ]
        },
        "_ilwzivhp75r7wuat": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.69
          }
        },
        "_bc6lfhgxb0wc36l9": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          },
          "indicators": [
            "CVD Binance P"
          ]
        },
        "_f8i6stuml3q7zwkc": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          }
        },
        "_pngsl31b0gpvtuas": {
          "scaleMargins": {
            "top": 0.04,
            "bottom": 0.8
          }
        },
        "_tdqicpndr092c1gk": {
          "scaleMargins": {
            "top": 0.21,
            "bottom": 0.69
          },
          "indicators": [
            "OI"
          ]
        }
      },
      "layouting": false,
      "showIndicators": true,
      "timeframe": "180",
      "refreshRate": 1000,
      "showAlerts": true,
      "showAlertsLabel": true,
      "showLegend": false,
      "fillGapsWithEmpty": true,
      "showHorizontalGridlines": false,
      "horizontalGridlinesColor": "rgba(255,255,255,.1)",
      "showVerticalGridlines": false,
      "verticalGridlinesColor": "rgba(255,255,255,.1)",
      "showWatermark": false,
      "watermarkColor": "rgba(255,255,255,.1)",
      "showBorder": true,
      "borderColor": null,
      "showLeftScale": false,
      "showRightScale": true,
      "showTimeScale": true,
      "hiddenMarkets": {},
      "barSpacing": 1.9866944899204444,
      "_id": "chart",
      "navigationState": {
        "tab": "script",
        "optionsQuery": "",
        "fontSizePx": 14
      }
    },
    "settings": {
      "_id": "settings",
      "preferQuoteCurrencySize": true,
      "aggregationLength": 1,
      "calculateSlippage": null,
      "wsProxyUrl": null,
      "disableAnimations": false,
      "autoHideHeaders": true,
      "autoHideNames": true,
      "theme": "dark",
      "backgroundColor": "rgb(23,27,41)",
      "textColor": "",
      "buyColor": "rgb(100, 157, 102)",
      "sellColor": "rgb(239, 67, 82)",
      "timezoneOffset": 0,
      "useAudio": false,
      "audioVolume": 1,
      "audioFilters": {
        "PingPongDelay": true,
        "Compressor": false,
        "Delay": false,
        "HighPassFilter": true,
        "LowPassFilter": false
      },
      "sections": [
        "settings-workspaces",
        "settings-trades",
        "timeframe-minutes",
        "search-extras",
        "indicator-left-script",
        "search-exchanges",
        "indicator-right-colors",
        "search-type",
        "trades-liquidations",
        "trades-thresholds",
        "trades-display"
      ],
      "searchTypes": {
        "recentSearches": true,
        "historical": false,
        "spots": false,
        "perpetuals": true,
        "futures": false,
        "normalize": false,
        "mergeUsdt": false
      },
      "searchQuotes": {},
      "previousSearchSelections": [
        {
          "label": "BTCUSD+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusd_perp",
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCUSDT",
            "OKEX:BTC-USD-SWAP",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 6
        },
        {
          "label": "BTCUSD+BTCPERP+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusd_perp",
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCPERP",
            "BYBIT:BTCUSD",
            "BYBIT:BTCUSDT",
            "OKEX:BTC-USD-SWAP",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 8
        },
        {
          "label": "BTCUSD+BTCPERP+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusd_perp",
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCPERP",
            "BYBIT:BTCUSD",
            "BYBIT:BTCUSDT",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 7
        },
        {
          "label": "BTCUSD+BTCPERP+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCPERP",
            "BYBIT:BTCUSD",
            "BYBIT:BTCUSDT",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 6
        },
        {
          "label": "BTCUSD+BTCPERP+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "BYBIT:BTCPERP",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 4
        },
        {
          "label": "BTCUSD+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 3
        },
        {
          "label": "BTCUSD+AGGRLSBTCUSD+AGGROIBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "ORDERBOOK:AGGRLS-BTCUSD",
            "ORDERBOOK:AGGROI-BTCUSD"
          ],
          "count": 4
        },
        {
          "label": "BTCUSD+AGGRLSBTCUSD",
          "markets": [
            "BINANCE_FUTURES:btcusdt",
            "BINANCE:btcusdt",
            "ORDERBOOK:AGGRLS-BTCUSD"
          ],
          "count": 3
        }
      ],
      "searchExchanges": {
        "AGGR": false,
        "BINANCE": false,
        "BINANCE_FUTURES": false,
        "BINANCE_US": false,
        "BITFINEX": false,
        "BITGET": false,
        "BITMART": false,
        "BITMEX": false,
        "BITSTAMP": false,
        "BYBIT": false,
        "COINBASE": false,
        "CRYPTOCOM": false,
        "DERIBIT": false,
        "DYDX": false,
        "GATEIO": false,
        "HITBTC": false,
        "HUOBI": false,
        "KRAKEN": false,
        "KUCOIN": false,
        "MEXC": false,
        "OKEX": true,
        "ORDERBOOK": false,
        "PHEMEX": false,
        "POLONIEX": false,
        "UNISWAP": false
      },
      "timeframes": [
        {
          "label": "1s",
          "value": "1"
        },
        {
          "label": "3s",
          "value": "3"
        },
        {
          "label": "5s",
          "value": "5"
        },
        {
          "label": "10s",
          "value": "10"
        },
        {
          "label": "15s",
          "value": "15"
        },
        {
          "label": "30s",
          "value": "30"
        },
        {
          "label": "1m",
          "value": "60"
        },
        {
          "label": "3m",
          "value": "180"
        },
        {
          "label": "5m",
          "value": "300"
        },
        {
          "label": "15m",
          "value": "900"
        },
        {
          "label": "21m",
          "value": "1260"
        },
        {
          "label": "30m",
          "value": "1800"
        },
        {
          "label": "1h",
          "value": "3600"
        },
        {
          "label": "2h",
          "value": "7200"
        },
        {
          "label": "4h",
          "value": "14400"
        },
        {
          "label": "6h",
          "value": "21600"
        },
        {
          "label": "8h",
          "value": "28800"
        },
        {
          "label": "12h",
          "value": "43200"
        },
        {
          "label": "1d",
          "value": "86400"
        },
        {
          "label": "21 ticks",
          "value": "21t"
        },
        {
          "label": "50 ticks",
          "value": "50t"
        },
        {
          "label": "89 ticks",
          "value": "89t"
        },
        {
          "label": "100 ticks",
          "value": "100t"
        },
        {
          "label": "200 ticks",
          "value": "200t"
        },
        {
          "label": "610 ticks",
          "value": "610t"
        },
        {
          "label": "1000 ticks",
          "value": "1000t"
        },
        {
          "label": "1597 ticks",
          "value": "1597t"
        }
      ],
      "favoriteTimeframes": {
        "60": "1m",
        "300": "5m"
      },
      "normalizeWatermarks": true,
      "alerts": true,
      "alertsColor": "rgb(0,255,0)",
      "alertsLineStyle": 1,
      "alertsLineWidth": 1,
      "alertsClick": false,
      "alertSound": null,
      "showThresholdsAsTable": true,
      "indicatorDialogNavigation": "{\"optionsQuery\":\"\",\"editorOptions\":{},\"columnWidth\":240,\"tab\":\"options\"}"
    }
  }
}